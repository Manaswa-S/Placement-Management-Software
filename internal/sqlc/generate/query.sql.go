// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const extraInfoCompany = `-- name: ExtraInfoCompany :one
INSERT INTO companies (company_name, representative_email, representative_contact, representative_name, data_url, user_id)
VALUES ($1, $2, $3, $4, $5, (SELECT user_id FROM users WHERE email = $6))
RETURNING company_id, company_name, representative_email, representative_contact, representative_name, data_url, user_id
`

type ExtraInfoCompanyParams struct {
	CompanyName           string
	RepresentativeEmail   string
	RepresentativeContact string
	RepresentativeName    string
	DataUrl               pgtype.Text
	Email                 string
}

func (q *Queries) ExtraInfoCompany(ctx context.Context, arg ExtraInfoCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, extraInfoCompany,
		arg.CompanyName,
		arg.RepresentativeEmail,
		arg.RepresentativeContact,
		arg.RepresentativeName,
		arg.DataUrl,
		arg.Email,
	)
	var i Company
	err := row.Scan(
		&i.CompanyID,
		&i.CompanyName,
		&i.RepresentativeEmail,
		&i.RepresentativeContact,
		&i.RepresentativeName,
		&i.DataUrl,
		&i.UserID,
	)
	return i, err
}

const extraInfoStudent = `-- name: ExtraInfoStudent :one
INSERT INTO students (student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, (SELECT user_id FROM users WHERE email = $15), $16)
RETURNING student_id, student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras
`

type ExtraInfoStudentParams struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	ResumeUrl    pgtype.Text
	ResultUrl    string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Email        string
	Extras       []byte
}

func (q *Queries) ExtraInfoStudent(ctx context.Context, arg ExtraInfoStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, extraInfoStudent,
		arg.StudentName,
		arg.RollNumber,
		arg.StudentDob,
		arg.Gender,
		arg.Course,
		arg.Department,
		arg.YearOfStudy,
		arg.ResumeUrl,
		arg.ResultUrl,
		arg.Cgpa,
		arg.ContactNo,
		arg.StudentEmail,
		arg.Address,
		arg.Skills,
		arg.Email,
		arg.Extras,
	)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.ResumeUrl,
		&i.ResultUrl,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.UserID,
		&i.Extras,
	)
	return i, err
}

const getAll = `-- name: GetAll :many
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users
`

func (q *Queries) GetAll(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.UserUuid,
			&i.CreatedAt,
			&i.Confirmed,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserData = `-- name: GetUserData :one
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users WHERE email = $1
`

func (q *Queries) GetUserData(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserData, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const insertNewJob = `-- name: InsertNewJob :one

INSERT INTO jobs (data_url, company_id, title, location, type, salary, skills, position, extras)
VALUES ($1, (SELECT company_id FROM companies WHERE representative_email = $2), $3, $4, $5, $6, $7, $8, $9)
RETURNING job_id, data_url, created_at, company_id, title, location, type, salary, skills, position, extras
`

type InsertNewJobParams struct {
	DataUrl             pgtype.Text
	RepresentativeEmail string
	Title               string
	Location            string
	Type                string
	Salary              string
	Skills              []string
	Position            string
	Extras              []byte
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Company queries
func (q *Queries) InsertNewJob(ctx context.Context, arg InsertNewJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, insertNewJob,
		arg.DataUrl,
		arg.RepresentativeEmail,
		arg.Title,
		arg.Location,
		arg.Type,
		arg.Salary,
		arg.Skills,
		arg.Position,
		arg.Extras,
	)
	var i Job
	err := row.Scan(
		&i.JobID,
		&i.DataUrl,
		&i.CreatedAt,
		&i.CompanyID,
		&i.Title,
		&i.Location,
		&i.Type,
		&i.Salary,
		&i.Skills,
		&i.Position,
		&i.Extras,
	)
	return i, err
}

const signupUser = `-- name: SignupUser :one
INSERT INTO users (email, password, role) VALUES ($1, $2, $3)
RETURNING user_id, email, password, role, user_uuid, created_at, confirmed, is_verified
`

type SignupUserParams struct {
	Email    string
	Password string
	Role     int64
}

func (q *Queries) SignupUser(ctx context.Context, arg SignupUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signupUser, arg.Email, arg.Password, arg.Role)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const updateEmailConfirmation = `-- name: UpdateEmailConfirmation :exec
UPDATE users
SET confirmed = true
WHERE email = $1
`

func (q *Queries) UpdateEmailConfirmation(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, updateEmailConfirmation, email)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password = $2
WHERE email = $1
`

type UpdatePasswordParams struct {
	Email    string
	Password string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.Email, arg.Password)
	return err
}
