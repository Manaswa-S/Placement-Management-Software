// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const applicationHistory = `-- name: ApplicationHistory :many
SELECT 
    applications.application_id,
    TO_CHAR(applications.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    jobs.title,
    companies.company_name
FROM applications
JOIN jobs ON jobs.job_id = applications.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT students.student_id FROM students WHERE students.user_id = $1)
ORDER BY applications.created_at DESC
`

type ApplicationHistoryRow struct {
	ApplicationID int64
	CreatedAt     string
	Title         string
	CompanyName   string
}

func (q *Queries) ApplicationHistory(ctx context.Context, userID int64) ([]ApplicationHistoryRow, error) {
	rows, err := q.db.Query(ctx, applicationHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationHistoryRow
	for rows.Next() {
		var i ApplicationHistoryRow
		if err := rows.Scan(
			&i.ApplicationID,
			&i.CreatedAt,
			&i.Title,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const applicationStatusTo = `-- name: ApplicationStatusTo :exec
UPDATE applications
SET status = $1
WHERE application_id = $2
`

type ApplicationStatusToParams struct {
	Status        interface{}
	ApplicationID int64
}

func (q *Queries) ApplicationStatusTo(ctx context.Context, arg ApplicationStatusToParams) error {
	_, err := q.db.Exec(ctx, applicationStatusTo, arg.Status, arg.ApplicationID)
	return err
}

const applicationStatusToAnd = `-- name: ApplicationStatusToAnd :exec
UPDATE applications
SET status = $1
WHERE application_id = $2 AND status = $3
`

type ApplicationStatusToAndParams struct {
	Status        interface{}
	ApplicationID int64
	Status_2      interface{}
}

func (q *Queries) ApplicationStatusToAnd(ctx context.Context, arg ApplicationStatusToAndParams) error {
	_, err := q.db.Exec(ctx, applicationStatusToAnd, arg.Status, arg.ApplicationID, arg.Status_2)
	return err
}

const applicationsStatusCounts = `-- name: ApplicationsStatusCounts :many
SELECT
    COUNT(applications.status) AS applied_count,
    COUNT(CASE WHEN applications.status = 'UnderReview' THEN 1 END) AS under_review_count,
    COUNT(CASE WHEN applications.status = 'ShortListed' THEN 1 END) AS shortlisted_count,
    COUNT(CASE WHEN applications.status = 'Rejected' THEN 1 END) AS rejected_count,
    COUNT(CASE WHEN applications.status = 'Offered' THEN 1 END) AS offered_count,
    COUNT(CASE WHEN applications.status = 'Hired' THEN 1 END) AS hired_count
FROM applications
WHERE applications.student_id = (SELECT students.student_id FROM students WHERE students.user_id = $1)
GROUP BY applications.student_id
`

type ApplicationsStatusCountsRow struct {
	AppliedCount     int64
	UnderReviewCount int64
	ShortlistedCount int64
	RejectedCount    int64
	OfferedCount     int64
	HiredCount       int64
}

func (q *Queries) ApplicationsStatusCounts(ctx context.Context, userID int64) ([]ApplicationsStatusCountsRow, error) {
	rows, err := q.db.Query(ctx, applicationsStatusCounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationsStatusCountsRow
	for rows.Next() {
		var i ApplicationsStatusCountsRow
		if err := rows.Scan(
			&i.AppliedCount,
			&i.UnderReviewCount,
			&i.ShortlistedCount,
			&i.RejectedCount,
			&i.OfferedCount,
			&i.HiredCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cancelApplication = `-- name: CancelApplication :exec
DELETE FROM applications 
WHERE student_id = (SELECT student_id FROM students WHERE students.user_id = $1) 
AND job_id = $2
`

type CancelApplicationParams struct {
	UserID int64
	JobID  int64
}

func (q *Queries) CancelApplication(ctx context.Context, arg CancelApplicationParams) error {
	_, err := q.db.Exec(ctx, cancelApplication, arg.UserID, arg.JobID)
	return err
}

const cancelInterviewEmailData = `-- name: CancelInterviewEmailData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name,
    t.date_time,
    c.representative_name,
    c.representative_email
FROM students
JOIN (
    SELECT 
        job_id, 
        student_id, 
        interviews.date_time
    FROM applications 
    JOIN interviews ON interviews.application_id = applications.application_id 
    WHERE applications.application_id = $1) AS t 
ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name, representative_name, representative_email FROM companies) AS c ON j.company_id = c.company_id
`

type CancelInterviewEmailDataRow struct {
	StudentName         string
	StudentEmail        string
	Title               string
	CompanyName         string
	DateTime            pgtype.Timestamptz
	RepresentativeName  string
	RepresentativeEmail string
}

func (q *Queries) CancelInterviewEmailData(ctx context.Context, applicationID int64) (CancelInterviewEmailDataRow, error) {
	row := q.db.QueryRow(ctx, cancelInterviewEmailData, applicationID)
	var i CancelInterviewEmailDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
		&i.DateTime,
		&i.RepresentativeName,
		&i.RepresentativeEmail,
	)
	return i, err
}

const closeJob = `-- name: CloseJob :exec
UPDATE jobs
SET active_status = false
WHERE jobs.job_id = $1 
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type CloseJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) CloseJob(ctx context.Context, arg CloseJobParams) error {
	_, err := q.db.Exec(ctx, closeJob, arg.JobID, arg.UserID)
	return err
}

const completedInterviews = `-- name: CompletedInterviews :many
SELECT 
    jobs.title,
    companies.company_name,
    interviews.interview_id,
    interviews.application_id,
    TO_CHAR(interviews.date_time, 'DD-MM-YYYY HH12:MI AM') AS date_time,
    interviews.extras
FROM interviews
JOIN applications ON interviews.application_id = applications.application_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
AND interviews.status = 'Completed'
`

type CompletedInterviewsRow struct {
	Title         string
	CompanyName   string
	InterviewID   int64
	ApplicationID int64
	DateTime      string
	Extras        []byte
}

func (q *Queries) CompletedInterviews(ctx context.Context, userID int64) ([]CompletedInterviewsRow, error) {
	rows, err := q.db.Query(ctx, completedInterviews, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompletedInterviewsRow
	for rows.Next() {
		var i CompletedInterviewsRow
		if err := rows.Scan(
			&i.Title,
			&i.CompanyName,
			&i.InterviewID,
			&i.ApplicationID,
			&i.DateTime,
			&i.Extras,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const completedTests = `-- name: CompletedTests :many
SELECT 
    testresults.result_id,
    TO_CHAR(testresults.start_time, 'DD-MM-YYYY HH12:MI AM') AS start_time,
    TO_CHAR(testresults.end_time, 'DD-MM-YYYY HH12:MI AM') AS end_time,
    companies.company_name,
    jobs.title
FROM testresults
JOIN tests ON testresults.test_id = tests.test_id
JOIN companies ON tests.company_id = companies.company_id
JOIN jobs ON tests.job_id = jobs.job_id
WHERE testresults.user_id = $1
AND testresults.end_time IS NOT NULL
ORDER BY testresults.result_id
`

type CompletedTestsRow struct {
	ResultID    int64
	StartTime   string
	EndTime     string
	CompanyName string
	Title       string
}

func (q *Queries) CompletedTests(ctx context.Context, userID int64) ([]CompletedTestsRow, error) {
	rows, err := q.db.Query(ctx, completedTests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompletedTestsRow
	for rows.Next() {
		var i CompletedTestsRow
		if err := rows.Scan(
			&i.ResultID,
			&i.StartTime,
			&i.EndTime,
			&i.CompanyName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteInterview = `-- name: DeleteInterview :exec
DELETE FROM interviews
WHERE application_id = $1
`

func (q *Queries) DeleteInterview(ctx context.Context, applicationID int64) error {
	_, err := q.db.Exec(ctx, deleteInterview, applicationID)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs 
WHERE jobs.job_id = $1
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type DeleteJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) DeleteJob(ctx context.Context, arg DeleteJobParams) error {
	_, err := q.db.Exec(ctx, deleteJob, arg.JobID, arg.UserID)
	return err
}

const extraInfoCompany = `-- name: ExtraInfoCompany :one
INSERT INTO companies (company_name, representative_email, representative_contact, representative_name, data_url, user_id)
VALUES ($1, $2, $3, $4, $5, (SELECT user_id FROM users WHERE email = $6))
RETURNING company_id, company_name, representative_email, representative_contact, representative_name, data_url, user_id
`

type ExtraInfoCompanyParams struct {
	CompanyName           string
	RepresentativeEmail   string
	RepresentativeContact string
	RepresentativeName    string
	DataUrl               pgtype.Text
	Email                 string
}

func (q *Queries) ExtraInfoCompany(ctx context.Context, arg ExtraInfoCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, extraInfoCompany,
		arg.CompanyName,
		arg.RepresentativeEmail,
		arg.RepresentativeContact,
		arg.RepresentativeName,
		arg.DataUrl,
		arg.Email,
	)
	var i Company
	err := row.Scan(
		&i.CompanyID,
		&i.CompanyName,
		&i.RepresentativeEmail,
		&i.RepresentativeContact,
		&i.RepresentativeName,
		&i.DataUrl,
		&i.UserID,
	)
	return i, err
}

const extraInfoStudent = `-- name: ExtraInfoStudent :one
INSERT INTO students (student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras, picture_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, (SELECT user_id FROM users WHERE email = $15), $16, $17)
RETURNING student_id, student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras, picture_url
`

type ExtraInfoStudentParams struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	ResumeUrl    pgtype.Text
	ResultUrl    string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Email        string
	Extras       []byte
	PictureUrl   pgtype.Text
}

func (q *Queries) ExtraInfoStudent(ctx context.Context, arg ExtraInfoStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, extraInfoStudent,
		arg.StudentName,
		arg.RollNumber,
		arg.StudentDob,
		arg.Gender,
		arg.Course,
		arg.Department,
		arg.YearOfStudy,
		arg.ResumeUrl,
		arg.ResultUrl,
		arg.Cgpa,
		arg.ContactNo,
		arg.StudentEmail,
		arg.Address,
		arg.Skills,
		arg.Email,
		arg.Extras,
		arg.PictureUrl,
	)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.ResumeUrl,
		&i.ResultUrl,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.UserID,
		&i.Extras,
		&i.PictureUrl,
	)
	return i, err
}

const getAll = `-- name: GetAll :many
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users
`

func (q *Queries) GetAll(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.UserUuid,
			&i.CreatedAt,
			&i.Confirmed,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllApplicantsEmailsForJob = `-- name: GetAllApplicantsEmailsForJob :many
SELECT 
    students.student_email
FROM applications
JOIN students ON applications.student_id = students.student_id
WHERE applications.job_id = $1
`

func (q *Queries) GetAllApplicantsEmailsForJob(ctx context.Context, jobID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllApplicantsEmailsForJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var student_email string
		if err := rows.Scan(&student_email); err != nil {
			return nil, err
		}
		items = append(items, student_email)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFilePaths = `-- name: GetAllFilePaths :one
SELECT 
    students.resume_url,
    students.result_url,
    students.picture_url
FROM students
WHERE user_id = $1
`

type GetAllFilePathsRow struct {
	ResumeUrl  pgtype.Text
	ResultUrl  string
	PictureUrl pgtype.Text
}

func (q *Queries) GetAllFilePaths(ctx context.Context, userID int64) (GetAllFilePathsRow, error) {
	row := q.db.QueryRow(ctx, getAllFilePaths, userID)
	var i GetAllFilePathsRow
	err := row.Scan(&i.ResumeUrl, &i.ResultUrl, &i.PictureUrl)
	return i, err
}

const getApplicableJobsTypeFilter = `-- name: GetApplicableJobsTypeFilter :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    jobs.active_status,
    companies.company_name 
FROM jobs
JOIN companies ON jobs.company_id = companies.company_id 
LEFT JOIN (SELECT applications.job_id FROM applications WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)) AS t 
ON jobs.job_id = t.job_id
WHERE t.job_id IS NULL 
AND (jobs.type = $2 OR $2 = 'All')
`

type GetApplicableJobsTypeFilterParams struct {
	UserID int64
	Type   string
}

type GetApplicableJobsTypeFilterRow struct {
	JobID        int64
	Title        string
	Location     string
	Type         string
	Salary       string
	Position     string
	Skills       []string
	CompanyID    int64
	ActiveStatus bool
	CompanyName  string
}

func (q *Queries) GetApplicableJobsTypeFilter(ctx context.Context, arg GetApplicableJobsTypeFilterParams) ([]GetApplicableJobsTypeFilterRow, error) {
	rows, err := q.db.Query(ctx, getApplicableJobsTypeFilter, arg.UserID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicableJobsTypeFilterRow
	for rows.Next() {
		var i GetApplicableJobsTypeFilterRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.ActiveStatus,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicants = `-- name: GetApplicants :many
SELECT
    students.student_id,
    students.student_name,
    students.roll_number,
    students.gender,
    students.department,
    students.student_email,
    students.contact_no,
    students.cgpa,
    students.skills,
    jobs.job_id, 
    jobs.title, 
    applications.status::TEXT AS status,
    COALESCE(interviews.status::TEXT, '') AS interview_status,
    applications.application_id
FROM applications
JOIN jobs ON applications.job_id = jobs.job_id
JOIN students ON applications.student_id = students.student_id
LEFT JOIN interviews ON applications.application_id = interviews.application_id
WHERE jobs.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
AND (jobs.job_id = $2 OR $2 = 0)
AND (applications.status != 'Rejected')
ORDER BY jobs.job_id
`

type GetApplicantsParams struct {
	UserID int64
	JobID  int64
}

type GetApplicantsRow struct {
	StudentID       int64
	StudentName     string
	RollNumber      string
	Gender          string
	Department      string
	StudentEmail    string
	ContactNo       string
	Cgpa            pgtype.Float8
	Skills          pgtype.Text
	JobID           int64
	Title           string
	Status          string
	InterviewStatus interface{}
	ApplicationID   int64
}

func (q *Queries) GetApplicants(ctx context.Context, arg GetApplicantsParams) ([]GetApplicantsRow, error) {
	rows, err := q.db.Query(ctx, getApplicants, arg.UserID, arg.JobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicantsRow
	for rows.Next() {
		var i GetApplicantsRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
			&i.Gender,
			&i.Department,
			&i.StudentEmail,
			&i.ContactNo,
			&i.Cgpa,
			&i.Skills,
			&i.JobID,
			&i.Title,
			&i.Status,
			&i.InterviewStatus,
			&i.ApplicationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobDetails = `-- name: GetJobDetails :one
SELECT 
    jobs.title,
    companies.company_name
FROM jobs 
JOIN companies ON jobs.company_id = companies.company_id
WHERE jobs.job_id = $1
`

type GetJobDetailsRow struct {
	Title       string
	CompanyName string
}

func (q *Queries) GetJobDetails(ctx context.Context, jobID int64) (GetJobDetailsRow, error) {
	row := q.db.QueryRow(ctx, getJobDetails, jobID)
	var i GetJobDetailsRow
	err := row.Scan(&i.Title, &i.CompanyName)
	return i, err
}

const getJobListings = `-- name: GetJobListings :many
SELECT 
    jobs.job_id,
    jobs.created_at::DATE as created_at,
    jobs.title,
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.skills,
    jobs.position,
    jobs.active_status,
    COALESCE(t.no_of_applications, 0),
    jobs.description,
    jobs.extras    
FROM jobs
LEFT JOIN (
    SELECT 
        job_id, 
        COUNT(job_id) AS no_of_applications 
    FROM applications 
    WHERE status != 'Rejected' 
    GROUP BY job_id ) AS t
ON jobs.job_id = t.job_id
WHERE jobs.company_id = (
    SELECT 
        companies.company_id 
    FROM companies 
    WHERE companies.user_id = $1)
`

type GetJobListingsRow struct {
	JobID            int64
	CreatedAt        pgtype.Date
	Title            string
	Location         string
	Type             string
	Salary           string
	Skills           []string
	Position         string
	ActiveStatus     bool
	NoOfApplications int64
	Description      pgtype.Text
	Extras           []byte
}

func (q *Queries) GetJobListings(ctx context.Context, userID int64) ([]GetJobListingsRow, error) {
	rows, err := q.db.Query(ctx, getJobListings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobListingsRow
	for rows.Next() {
		var i GetJobListingsRow
		if err := rows.Scan(
			&i.JobID,
			&i.CreatedAt,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Skills,
			&i.Position,
			&i.ActiveStatus,
			&i.NoOfApplications,
			&i.Description,
			&i.Extras,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyApplicationsStatusFilter = `-- name: GetMyApplicationsStatusFilter :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    companies.company_name,
    companies.representative_email,
    companies.representative_name,
    applications.status::TEXT AS status
FROM applications
JOIN students ON applications.student_id = students.student_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE students.user_id = $1 
  AND ($2 = 'All' OR applications.status::TEXT = $2)
ORDER BY jobs.job_id
`

type GetMyApplicationsStatusFilterParams struct {
	UserID  int64
	Column2 interface{}
}

type GetMyApplicationsStatusFilterRow struct {
	JobID               int64
	Title               string
	Location            string
	Type                string
	Salary              string
	Position            string
	Skills              []string
	CompanyID           int64
	CompanyName         string
	RepresentativeEmail string
	RepresentativeName  string
	Status              string
}

func (q *Queries) GetMyApplicationsStatusFilter(ctx context.Context, arg GetMyApplicationsStatusFilterParams) ([]GetMyApplicationsStatusFilterRow, error) {
	rows, err := q.db.Query(ctx, getMyApplicationsStatusFilter, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyApplicationsStatusFilterRow
	for rows.Next() {
		var i GetMyApplicationsStatusFilterRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.CompanyName,
			&i.RepresentativeEmail,
			&i.RepresentativeName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferLetterData = `-- name: GetOfferLetterData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name,
    c.representative_contact,
    c.representative_email
FROM students
JOIN (SELECT job_id, student_id FROM applications WHERE application_id = $1) AS t ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name, representative_contact, representative_email FROM companies) AS c ON j.company_id = c.company_id
`

type GetOfferLetterDataRow struct {
	StudentName           string
	StudentEmail          string
	Title                 string
	CompanyName           string
	RepresentativeContact string
	RepresentativeEmail   string
}

func (q *Queries) GetOfferLetterData(ctx context.Context, applicationID int64) (GetOfferLetterDataRow, error) {
	row := q.db.QueryRow(ctx, getOfferLetterData, applicationID)
	var i GetOfferLetterDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
		&i.RepresentativeContact,
		&i.RepresentativeEmail,
	)
	return i, err
}

const getResumeAndResultPath = `-- name: GetResumeAndResultPath :one
SELECT 
    resume_url, 
    result_url
FROM students 
JOIN applications 
ON applications.student_id = students.student_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.application_id = $1
AND companies.user_id = $2
`

type GetResumeAndResultPathParams struct {
	ApplicationID int64
	UserID        int64
}

type GetResumeAndResultPathRow struct {
	ResumeUrl pgtype.Text
	ResultUrl string
}

func (q *Queries) GetResumeAndResultPath(ctx context.Context, arg GetResumeAndResultPathParams) (GetResumeAndResultPathRow, error) {
	row := q.db.QueryRow(ctx, getResumeAndResultPath, arg.ApplicationID, arg.UserID)
	var i GetResumeAndResultPathRow
	err := row.Scan(&i.ResumeUrl, &i.ResultUrl)
	return i, err
}

const getScheduleInterviewData = `-- name: GetScheduleInterviewData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name
FROM students
JOIN (SELECT job_id, student_id FROM applications WHERE application_id = $1) AS t ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name FROM companies) AS c ON j.company_id = c.company_id
`

type GetScheduleInterviewDataRow struct {
	StudentName  string
	StudentEmail string
	Title        string
	CompanyName  string
}

func (q *Queries) GetScheduleInterviewData(ctx context.Context, applicationID int64) (GetScheduleInterviewDataRow, error) {
	row := q.db.QueryRow(ctx, getScheduleInterviewData, applicationID)
	var i GetScheduleInterviewDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
	)
	return i, err
}

const getUserData = `-- name: GetUserData :one
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users WHERE email = $1
`

func (q *Queries) GetUserData(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserData, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const getUserIDCompanyIDJobIDApplicationID = `-- name: GetUserIDCompanyIDJobIDApplicationID :one
SELECT 
    companies.user_id
FROM companies
JOIN jobs ON jobs.company_id = companies.company_id
JOIN applications ON applications.job_id = jobs.job_id
WHERE applications.application_id = $1
`

func (q *Queries) GetUserIDCompanyIDJobIDApplicationID(ctx context.Context, applicationID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDCompanyIDJobIDApplicationID, applicationID)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserUUIDFromEmail = `-- name: GetUserUUIDFromEmail :one
SELECT 
    users.user_uuid
FROM users 
WHERE users.email = $1
`

func (q *Queries) GetUserUUIDFromEmail(ctx context.Context, email string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getUserUUIDFromEmail, email)
	var user_uuid pgtype.UUID
	err := row.Scan(&user_uuid)
	return user_uuid, err
}

const getUserUUIDFromUserID = `-- name: GetUserUUIDFromUserID :one
SELECT 
    users.user_uuid
FROM users 
WHERE users.user_id = $1
`

func (q *Queries) GetUserUUIDFromUserID(ctx context.Context, userID int64) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getUserUUIDFromUserID, userID)
	var user_uuid pgtype.UUID
	err := row.Scan(&user_uuid)
	return user_uuid, err
}

const insertNewApplication = `-- name: InsertNewApplication :exec
INSERT INTO applications (job_id, student_id, data_url) 
VALUES ($1, (SELECT student_id FROM students WHERE user_id = $2), $3)
`

type InsertNewApplicationParams struct {
	JobID   int64
	UserID  int64
	DataUrl pgtype.Text
}

func (q *Queries) InsertNewApplication(ctx context.Context, arg InsertNewApplicationParams) error {
	_, err := q.db.Exec(ctx, insertNewApplication, arg.JobID, arg.UserID, arg.DataUrl)
	return err
}

const insertNewJob = `-- name: InsertNewJob :exec

INSERT INTO jobs (data_url, company_id, title, location, type, salary, skills, position, extras, description)
VALUES ($1, (SELECT company_id FROM companies WHERE companies.user_id = $2), $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertNewJobParams struct {
	DataUrl     pgtype.Text
	UserID      int64
	Title       string
	Location    string
	Type        string
	Salary      string
	Skills      []string
	Position    string
	Extras      []byte
	Description pgtype.Text
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Company queries
func (q *Queries) InsertNewJob(ctx context.Context, arg InsertNewJobParams) error {
	_, err := q.db.Exec(ctx, insertNewJob,
		arg.DataUrl,
		arg.UserID,
		arg.Title,
		arg.Location,
		arg.Type,
		arg.Salary,
		arg.Skills,
		arg.Position,
		arg.Extras,
		arg.Description,
	)
	return err
}

const interviewHistory = `-- name: InterviewHistory :many
SELECT 
    interviews.interview_id,
    TO_CHAR(interviews.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    jobs.title
FROM interviews
JOIN applications ON applications.application_id = interviews.application_id
JOIN jobs ON jobs.job_id = applications.job_id
WHERE applications.student_id = (SELECT students.student_id FROM students WHERE students.user_id = $1)
ORDER BY interviews.created_at DESC
`

type InterviewHistoryRow struct {
	InterviewID int64
	CreatedAt   string
	Title       string
}

func (q *Queries) InterviewHistory(ctx context.Context, userID int64) ([]InterviewHistoryRow, error) {
	rows, err := q.db.Query(ctx, interviewHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InterviewHistoryRow
	for rows.Next() {
		var i InterviewHistoryRow
		if err := rows.Scan(&i.InterviewID, &i.CreatedAt, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const interviewStatusTo = `-- name: InterviewStatusTo :exec
UPDATE interviews
SET status = $1
WHERE application_id = $2
`

type InterviewStatusToParams struct {
	Status        interface{}
	ApplicationID int64
}

func (q *Queries) InterviewStatusTo(ctx context.Context, arg InterviewStatusToParams) error {
	_, err := q.db.Exec(ctx, interviewStatusTo, arg.Status, arg.ApplicationID)
	return err
}

const isTestGiven = `-- name: IsTestGiven :one
SELECT 
    testresults.test_id,
    testresults.start_time,
    testresults.end_time
FROM testresults
WHERE testresults.test_id = $1 
AND testresults.user_id = $2
`

type IsTestGivenParams struct {
	TestID int64
	UserID int64
}

type IsTestGivenRow struct {
	TestID    int64
	StartTime pgtype.Timestamptz
	EndTime   pgtype.Timestamptz
}

func (q *Queries) IsTestGiven(ctx context.Context, arg IsTestGivenParams) (IsTestGivenRow, error) {
	row := q.db.QueryRow(ctx, isTestGiven, arg.TestID, arg.UserID)
	var i IsTestGivenRow
	err := row.Scan(&i.TestID, &i.StartTime, &i.EndTime)
	return i, err
}

const listToVerifyStudent = `-- name: ListToVerifyStudent :many
SELECT 
    users.user_id,
    users.email,
    TO_CHAR(users.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    users.confirmed
FROM users
WHERE users.confirmed = true
AND users.is_verified = false
AND users.role = 1
`

type ListToVerifyStudentRow struct {
	UserID    int64
	Email     string
	CreatedAt string
	Confirmed bool
}

func (q *Queries) ListToVerifyStudent(ctx context.Context) ([]ListToVerifyStudentRow, error) {
	rows, err := q.db.Query(ctx, listToVerifyStudent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListToVerifyStudentRow
	for rows.Next() {
		var i ListToVerifyStudentRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.CreatedAt,
			&i.Confirmed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newTest = `-- name: NewTest :exec
INSERT INTO tests (test_name, description, duration, q_count, end_time, type, upload_method, job_id, company_id, file_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, (SELECT company_id FROM companies WHERE user_id = $9), $10)
`

type NewTestParams struct {
	TestName     string
	Description  pgtype.Text
	Duration     int64
	QCount       int64
	EndTime      pgtype.Timestamptz
	Type         string
	UploadMethod interface{}
	JobID        pgtype.Int8
	UserID       int64
	FileID       string
}

func (q *Queries) NewTest(ctx context.Context, arg NewTestParams) error {
	_, err := q.db.Exec(ctx, newTest,
		arg.TestName,
		arg.Description,
		arg.Duration,
		arg.QCount,
		arg.EndTime,
		arg.Type,
		arg.UploadMethod,
		arg.JobID,
		arg.UserID,
		arg.FileID,
	)
	return err
}

const newTestResult = `-- name: NewTestResult :exec
INSERT INTO testresults (test_id, user_id, start_time)
VALUES ($1, $2, $3)
`

type NewTestResultParams struct {
	TestID    int64
	UserID    int64
	StartTime pgtype.Timestamptz
}

func (q *Queries) NewTestResult(ctx context.Context, arg NewTestResultParams) error {
	_, err := q.db.Exec(ctx, newTestResult, arg.TestID, arg.UserID, arg.StartTime)
	return err
}

const profileData = `-- name: ProfileData :one
SELECT 
    students.student_name,
    students.roll_number,
    students.student_dob,
    students.gender,
    students.course,
    students.department,
    students.year_of_study,
    students.cgpa,
    students.contact_no,
    students.student_email,
    students.address,
    students.skills,
    students.extras
FROM students
WHERE students.user_id = $1
`

type ProfileDataRow struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Extras       []byte
}

func (q *Queries) ProfileData(ctx context.Context, userID int64) (ProfileDataRow, error) {
	row := q.db.QueryRow(ctx, profileData, userID)
	var i ProfileDataRow
	err := row.Scan(
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.Extras,
	)
	return i, err
}

const scheduleInterview = `-- name: ScheduleInterview :exec
INSERT INTO interviews (application_id, company_id, date_time, type, notes, location)
VALUES ($1, (SELECT company_id FROM companies WHERE user_id = $2), $3, $4, $5, $6)
`

type ScheduleInterviewParams struct {
	ApplicationID int64
	UserID        int64
	DateTime      pgtype.Timestamptz
	Type          interface{}
	Notes         pgtype.Text
	Location      string
}

func (q *Queries) ScheduleInterview(ctx context.Context, arg ScheduleInterviewParams) error {
	_, err := q.db.Exec(ctx, scheduleInterview,
		arg.ApplicationID,
		arg.UserID,
		arg.DateTime,
		arg.Type,
		arg.Notes,
		arg.Location,
	)
	return err
}

const signupUser = `-- name: SignupUser :one
INSERT INTO users (email, password, role) VALUES ($1, $2, $3)
RETURNING user_id, email, password, role, user_uuid, created_at, confirmed, is_verified
`

type SignupUserParams struct {
	Email    string
	Password string
	Role     int64
}

func (q *Queries) SignupUser(ctx context.Context, arg SignupUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signupUser, arg.Email, arg.Password, arg.Role)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const studentInfo = `-- name: StudentInfo :one
SELECT
    students.student_id,
    students.student_name,
    students.roll_number,
    students.student_dob,
    students.gender,
    students.course,
    students.department,
    students.year_of_study,
    students.cgpa,
    students.contact_no,
    students.address,
    students.skills, 
    students.picture_url AS profilePic,
    students.extras
FROM students
WHERE students.user_id = $1
`

type StudentInfoRow struct {
	StudentID   int64
	StudentName string
	RollNumber  string
	StudentDob  pgtype.Date
	Gender      string
	Course      string
	Department  string
	YearOfStudy string
	Cgpa        pgtype.Float8
	ContactNo   string
	Address     pgtype.Text
	Skills      pgtype.Text
	Profilepic  pgtype.Text
	Extras      []byte
}

func (q *Queries) StudentInfo(ctx context.Context, userID int64) (StudentInfoRow, error) {
	row := q.db.QueryRow(ctx, studentInfo, userID)
	var i StudentInfoRow
	err := row.Scan(
		&i.StudentID,
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.Cgpa,
		&i.ContactNo,
		&i.Address,
		&i.Skills,
		&i.Profilepic,
		&i.Extras,
	)
	return i, err
}

const studentsOverview = `-- name: StudentsOverview :many
SELECT 
    students.student_id,
    students.student_name,
    students.roll_number,
    students.student_dob,
    students.gender,
    students.course,
    students.department,
    students.year_of_study,
    students.cgpa,
    students.contact_no,
    students.address,
    students.skills, 
    students.extras
FROM students
`

type StudentsOverviewRow struct {
	StudentID   int64
	StudentName string
	RollNumber  string
	StudentDob  pgtype.Date
	Gender      string
	Course      string
	Department  string
	YearOfStudy string
	Cgpa        pgtype.Float8
	ContactNo   string
	Address     pgtype.Text
	Skills      pgtype.Text
	Extras      []byte
}

func (q *Queries) StudentsOverview(ctx context.Context) ([]StudentsOverviewRow, error) {
	rows, err := q.db.Query(ctx, studentsOverview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentsOverviewRow
	for rows.Next() {
		var i StudentsOverviewRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
			&i.StudentDob,
			&i.Gender,
			&i.Course,
			&i.Department,
			&i.YearOfStudy,
			&i.Cgpa,
			&i.ContactNo,
			&i.Address,
			&i.Skills,
			&i.Extras,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const submitTest = `-- name: SubmitTest :one
UPDATE testresults 
SET end_time = $1
WHERE user_id = $2 
AND test_id = $3
RETURNING result_id
`

type SubmitTestParams struct {
	EndTime pgtype.Timestamptz
	UserID  int64
	TestID  int64
}

func (q *Queries) SubmitTest(ctx context.Context, arg SubmitTestParams) (int64, error) {
	row := q.db.QueryRow(ctx, submitTest, arg.EndTime, arg.UserID, arg.TestID)
	var result_id int64
	err := row.Scan(&result_id)
	return result_id, err
}

const takeTest = `-- name: TakeTest :one
SELECT 
    tests.file_id,
    tests.duration
FROM tests
JOIN applications ON applications.job_id = tests.job_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE user_id = $1)
AND tests.test_id = $2
`

type TakeTestParams struct {
	UserID int64
	TestID int64
}

type TakeTestRow struct {
	FileID   string
	Duration int64
}

func (q *Queries) TakeTest(ctx context.Context, arg TakeTestParams) (TakeTestRow, error) {
	row := q.db.QueryRow(ctx, takeTest, arg.UserID, arg.TestID)
	var i TakeTestRow
	err := row.Scan(&i.FileID, &i.Duration)
	return i, err
}

const testHistory = `-- name: TestHistory :many
SELECT 
    tests.test_id,
    tests.test_name,
    TO_CHAR(testresults.start_time, 'HH12:MI AM DD-MM-YYYY') AS start_time
FROM testresults
JOIN tests ON testresults.test_id = tests.test_id
WHERE testresults.user_id = $1
ORDER BY testresults.start_time DESC
`

type TestHistoryRow struct {
	TestID    int64
	TestName  string
	StartTime string
}

func (q *Queries) TestHistory(ctx context.Context, userID int64) ([]TestHistoryRow, error) {
	rows, err := q.db.Query(ctx, testHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestHistoryRow
	for rows.Next() {
		var i TestHistoryRow
		if err := rows.Scan(&i.TestID, &i.TestName, &i.StartTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testMetadata = `-- name: TestMetadata :one
SELECT 
    tests.test_id,
    tests.test_name,
    tests.description,
    tests.duration,
    tests.q_count,
    TO_CHAR(tests.end_time, 'HH12:MI AM DD-MM-YYYY') AS end_time,
    tests.type,    
    companies.company_name,
    jobs.title
FROM applications
JOIN tests ON applications.job_id = tests.job_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
AND tests.test_id = $2
`

type TestMetadataParams struct {
	UserID int64
	TestID int64
}

type TestMetadataRow struct {
	TestID      int64
	TestName    string
	Description pgtype.Text
	Duration    int64
	QCount      int64
	EndTime     string
	Type        string
	CompanyName string
	Title       string
}

func (q *Queries) TestMetadata(ctx context.Context, arg TestMetadataParams) (TestMetadataRow, error) {
	row := q.db.QueryRow(ctx, testMetadata, arg.UserID, arg.TestID)
	var i TestMetadataRow
	err := row.Scan(
		&i.TestID,
		&i.TestName,
		&i.Description,
		&i.Duration,
		&i.QCount,
		&i.EndTime,
		&i.Type,
		&i.CompanyName,
		&i.Title,
	)
	return i, err
}

const upcomingInterviews = `-- name: UpcomingInterviews :many
SELECT 
    companies.company_name,
    jobs.title,
    interviews.interview_id,
    (interviews.date_time)::DATE AS date,
    (interviews.date_time)::TIME::TEXT AS time,
    interviews.type::TEXT,
    interviews.location,
    interviews.notes
FROM applications
JOIN interviews ON applications.application_id = interviews.application_id 
                AND interviews.status != 'Completed'
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
`

type UpcomingInterviewsRow struct {
	CompanyName    string
	Title          string
	InterviewID    int64
	Date           pgtype.Date
	Time           string
	InterviewsType string
	Location       string
	Notes          pgtype.Text
}

func (q *Queries) UpcomingInterviews(ctx context.Context, userID int64) ([]UpcomingInterviewsRow, error) {
	rows, err := q.db.Query(ctx, upcomingInterviews, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpcomingInterviewsRow
	for rows.Next() {
		var i UpcomingInterviewsRow
		if err := rows.Scan(
			&i.CompanyName,
			&i.Title,
			&i.InterviewID,
			&i.Date,
			&i.Time,
			&i.InterviewsType,
			&i.Location,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upcomingTests = `-- name: UpcomingTests :many
SELECT 
    tests.test_id,
    tests.test_name,
    tests.description,
    tests.duration,
    tests.q_count,
    TO_CHAR(tests.end_time, 'DD-MM-YYYY HH12:MI AM') AS end_time,
    tests.type,    
    companies.company_name,
    jobs.title
FROM applications 
JOIN tests ON applications.job_id = tests.job_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
AND NOT EXISTS (SELECT 1 FROM testresults WHERE testresults.test_id = tests.test_id)
`

type UpcomingTestsRow struct {
	TestID      int64
	TestName    string
	Description pgtype.Text
	Duration    int64
	QCount      int64
	EndTime     string
	Type        string
	CompanyName string
	Title       string
}

func (q *Queries) UpcomingTests(ctx context.Context, userID int64) ([]UpcomingTestsRow, error) {
	rows, err := q.db.Query(ctx, upcomingTests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpcomingTestsRow
	for rows.Next() {
		var i UpcomingTestsRow
		if err := rows.Scan(
			&i.TestID,
			&i.TestName,
			&i.Description,
			&i.Duration,
			&i.QCount,
			&i.EndTime,
			&i.Type,
			&i.CompanyName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmailConfirmation = `-- name: UpdateEmailConfirmation :exec
UPDATE users
SET confirmed = true
WHERE email = $1
`

func (q *Queries) UpdateEmailConfirmation(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, updateEmailConfirmation, email)
	return err
}

const updateJob = `-- name: UpdateJob :exec
UPDATE jobs
SET location = $1,
    title = $2,
    description = $3,
    type = $4,
    salary = $5,
    skills = $6,
    position = $7,
    extras = $8
WHERE job_id = $9
AND company_id = (SELECT company_id FROM companies WHERE companies.user_id = $10)
`

type UpdateJobParams struct {
	Location    string
	Title       string
	Description pgtype.Text
	Type        string
	Salary      string
	Skills      []string
	Position    string
	Extras      []byte
	JobID       int64
	UserID      int64
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) error {
	_, err := q.db.Exec(ctx, updateJob,
		arg.Location,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.Salary,
		arg.Skills,
		arg.Position,
		arg.Extras,
		arg.JobID,
		arg.UserID,
	)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password = $2
WHERE email = $1
`

type UpdatePasswordParams struct {
	Email    string
	Password string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.Email, arg.Password)
	return err
}

const updateResponse = `-- name: UpdateResponse :exec
UPDATE testresults 
SET responses = responses || $1::jsonb
WHERE user_id = $2 
AND test_id = $3
`

type UpdateResponseParams struct {
	Column1 []byte
	UserID  int64
	TestID  int64
}

func (q *Queries) UpdateResponse(ctx context.Context, arg UpdateResponseParams) error {
	_, err := q.db.Exec(ctx, updateResponse, arg.Column1, arg.UserID, arg.TestID)
	return err
}

const updateStudentDetails = `-- name: UpdateStudentDetails :exec
UPDATE students
SET course = $1,
    department = $2,
    year_of_study = $3,
    cgpa = $4,
    contact_no = $5,
    address = $6,
    skills = $7
WHERE user_id = $8
`

type UpdateStudentDetailsParams struct {
	Course      string
	Department  string
	YearOfStudy string
	Cgpa        pgtype.Float8
	ContactNo   string
	Address     pgtype.Text
	Skills      pgtype.Text
	UserID      int64
}

func (q *Queries) UpdateStudentDetails(ctx context.Context, arg UpdateStudentDetailsParams) error {
	_, err := q.db.Exec(ctx, updateStudentDetails,
		arg.Course,
		arg.Department,
		arg.YearOfStudy,
		arg.Cgpa,
		arg.ContactNo,
		arg.Address,
		arg.Skills,
		arg.UserID,
	)
	return err
}

const updateStudentProfilePic = `-- name: UpdateStudentProfilePic :exec
UPDATE students
SET
    picture_url = $1
WHERE user_id = $2
`

type UpdateStudentProfilePicParams struct {
	PictureUrl pgtype.Text
	UserID     int64
}

func (q *Queries) UpdateStudentProfilePic(ctx context.Context, arg UpdateStudentProfilePicParams) error {
	_, err := q.db.Exec(ctx, updateStudentProfilePic, arg.PictureUrl, arg.UserID)
	return err
}

const updateStudentResult = `-- name: UpdateStudentResult :exec
UPDATE students
SET
    result_url = $1
WHERE user_id = $2
`

type UpdateStudentResultParams struct {
	ResultUrl string
	UserID    int64
}

func (q *Queries) UpdateStudentResult(ctx context.Context, arg UpdateStudentResultParams) error {
	_, err := q.db.Exec(ctx, updateStudentResult, arg.ResultUrl, arg.UserID)
	return err
}

const updateStudentResume = `-- name: UpdateStudentResume :exec
UPDATE students
SET
    resume_url = $1
WHERE user_id = $2
`

type UpdateStudentResumeParams struct {
	ResumeUrl pgtype.Text
	UserID    int64
}

func (q *Queries) UpdateStudentResume(ctx context.Context, arg UpdateStudentResumeParams) error {
	_, err := q.db.Exec(ctx, updateStudentResume, arg.ResumeUrl, arg.UserID)
	return err
}

const usersTableData = `-- name: UsersTableData :one
SELECT 
    TO_CHAR(users.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    users.confirmed,
    users.is_verified
FROM users
WHERE users.user_id = $1
`

type UsersTableDataRow struct {
	CreatedAt  string
	Confirmed  bool
	IsVerified bool
}

func (q *Queries) UsersTableData(ctx context.Context, userID int64) (UsersTableDataRow, error) {
	row := q.db.QueryRow(ctx, usersTableData, userID)
	var i UsersTableDataRow
	err := row.Scan(&i.CreatedAt, &i.Confirmed, &i.IsVerified)
	return i, err
}

const verifyStudent = `-- name: VerifyStudent :exec
UPDATE users
SET is_verified = true
WHERE user_id = $1
`

func (q *Queries) VerifyStudent(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, verifyStudent, userID)
	return err
}
