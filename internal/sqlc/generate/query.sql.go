// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const applicationStatusTo = `-- name: ApplicationStatusTo :exec
UPDATE applications
SET status = $1
WHERE application_id = $2
`

type ApplicationStatusToParams struct {
	Status        interface{}
	ApplicationID int64
}

func (q *Queries) ApplicationStatusTo(ctx context.Context, arg ApplicationStatusToParams) error {
	_, err := q.db.Exec(ctx, applicationStatusTo, arg.Status, arg.ApplicationID)
	return err
}

const applicationStatusToAnd = `-- name: ApplicationStatusToAnd :exec
UPDATE applications
SET status = $1
WHERE application_id = $2 AND status = $3
`

type ApplicationStatusToAndParams struct {
	Status        interface{}
	ApplicationID int64
	Status_2      interface{}
}

func (q *Queries) ApplicationStatusToAnd(ctx context.Context, arg ApplicationStatusToAndParams) error {
	_, err := q.db.Exec(ctx, applicationStatusToAnd, arg.Status, arg.ApplicationID, arg.Status_2)
	return err
}

const cancelApplication = `-- name: CancelApplication :exec
DELETE FROM applications 
WHERE student_id = (SELECT student_id FROM students WHERE students.user_id = $1) 
AND job_id = $2
`

type CancelApplicationParams struct {
	UserID int64
	JobID  int64
}

func (q *Queries) CancelApplication(ctx context.Context, arg CancelApplicationParams) error {
	_, err := q.db.Exec(ctx, cancelApplication, arg.UserID, arg.JobID)
	return err
}

const cancelInterviewEmailData = `-- name: CancelInterviewEmailData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name,
    t.date_time,
    c.representative_name,
    c.representative_email
FROM students
JOIN (
    SELECT 
        job_id, 
        student_id, 
        interviews.date_time
    FROM applications 
    JOIN interviews ON interviews.application_id = applications.application_id 
    WHERE applications.application_id = $1) AS t 
ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name, representative_name, representative_email FROM companies) AS c ON j.company_id = c.company_id
`

type CancelInterviewEmailDataRow struct {
	StudentName         string
	StudentEmail        string
	Title               string
	CompanyName         string
	DateTime            pgtype.Timestamptz
	RepresentativeName  string
	RepresentativeEmail string
}

func (q *Queries) CancelInterviewEmailData(ctx context.Context, applicationID int64) (CancelInterviewEmailDataRow, error) {
	row := q.db.QueryRow(ctx, cancelInterviewEmailData, applicationID)
	var i CancelInterviewEmailDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
		&i.DateTime,
		&i.RepresentativeName,
		&i.RepresentativeEmail,
	)
	return i, err
}

const closeJob = `-- name: CloseJob :exec
UPDATE jobs
SET active_status = false
WHERE jobs.job_id = $1 
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type CloseJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) CloseJob(ctx context.Context, arg CloseJobParams) error {
	_, err := q.db.Exec(ctx, closeJob, arg.JobID, arg.UserID)
	return err
}

const deleteInterview = `-- name: DeleteInterview :exec
DELETE FROM interviews
WHERE application_id = $1
`

func (q *Queries) DeleteInterview(ctx context.Context, applicationID int64) error {
	_, err := q.db.Exec(ctx, deleteInterview, applicationID)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs 
WHERE jobs.job_id = $1
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type DeleteJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) DeleteJob(ctx context.Context, arg DeleteJobParams) error {
	_, err := q.db.Exec(ctx, deleteJob, arg.JobID, arg.UserID)
	return err
}

const extraInfoCompany = `-- name: ExtraInfoCompany :one
INSERT INTO companies (company_name, representative_email, representative_contact, representative_name, data_url, user_id)
VALUES ($1, $2, $3, $4, $5, (SELECT user_id FROM users WHERE email = $6))
RETURNING company_id, company_name, representative_email, representative_contact, representative_name, data_url, user_id
`

type ExtraInfoCompanyParams struct {
	CompanyName           string
	RepresentativeEmail   string
	RepresentativeContact string
	RepresentativeName    string
	DataUrl               pgtype.Text
	Email                 string
}

func (q *Queries) ExtraInfoCompany(ctx context.Context, arg ExtraInfoCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, extraInfoCompany,
		arg.CompanyName,
		arg.RepresentativeEmail,
		arg.RepresentativeContact,
		arg.RepresentativeName,
		arg.DataUrl,
		arg.Email,
	)
	var i Company
	err := row.Scan(
		&i.CompanyID,
		&i.CompanyName,
		&i.RepresentativeEmail,
		&i.RepresentativeContact,
		&i.RepresentativeName,
		&i.DataUrl,
		&i.UserID,
	)
	return i, err
}

const extraInfoStudent = `-- name: ExtraInfoStudent :one
INSERT INTO students (student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, (SELECT user_id FROM users WHERE email = $15), $16)
RETURNING student_id, student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras
`

type ExtraInfoStudentParams struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	ResumeUrl    pgtype.Text
	ResultUrl    string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Email        string
	Extras       []byte
}

func (q *Queries) ExtraInfoStudent(ctx context.Context, arg ExtraInfoStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, extraInfoStudent,
		arg.StudentName,
		arg.RollNumber,
		arg.StudentDob,
		arg.Gender,
		arg.Course,
		arg.Department,
		arg.YearOfStudy,
		arg.ResumeUrl,
		arg.ResultUrl,
		arg.Cgpa,
		arg.ContactNo,
		arg.StudentEmail,
		arg.Address,
		arg.Skills,
		arg.Email,
		arg.Extras,
	)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.ResumeUrl,
		&i.ResultUrl,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.UserID,
		&i.Extras,
	)
	return i, err
}

const getAll = `-- name: GetAll :many
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users
`

func (q *Queries) GetAll(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.UserUuid,
			&i.CreatedAt,
			&i.Confirmed,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllApplicantsEmailsForJob = `-- name: GetAllApplicantsEmailsForJob :many
SELECT 
    students.student_email
FROM applications
JOIN students ON applications.student_id = students.student_id
WHERE applications.job_id = $1
`

func (q *Queries) GetAllApplicantsEmailsForJob(ctx context.Context, jobID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllApplicantsEmailsForJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var student_email string
		if err := rows.Scan(&student_email); err != nil {
			return nil, err
		}
		items = append(items, student_email)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicableJobsTypeFilter = `-- name: GetApplicableJobsTypeFilter :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    jobs.active_status,
    companies.company_name 
FROM jobs
JOIN companies ON jobs.company_id = companies.company_id 
LEFT JOIN (SELECT applications.job_id FROM applications WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)) AS t 
ON jobs.job_id = t.job_id
WHERE t.job_id IS NULL 
AND (jobs.type = $2 OR $2 = 'All')
`

type GetApplicableJobsTypeFilterParams struct {
	UserID int64
	Type   string
}

type GetApplicableJobsTypeFilterRow struct {
	JobID        int64
	Title        string
	Location     string
	Type         string
	Salary       string
	Position     string
	Skills       []string
	CompanyID    int64
	ActiveStatus bool
	CompanyName  string
}

func (q *Queries) GetApplicableJobsTypeFilter(ctx context.Context, arg GetApplicableJobsTypeFilterParams) ([]GetApplicableJobsTypeFilterRow, error) {
	rows, err := q.db.Query(ctx, getApplicableJobsTypeFilter, arg.UserID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicableJobsTypeFilterRow
	for rows.Next() {
		var i GetApplicableJobsTypeFilterRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.ActiveStatus,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicants = `-- name: GetApplicants :many
SELECT
    students.student_id,
    students.student_name,
    students.roll_number,
    students.gender,
    students.department,
    students.student_email,
    students.contact_no,
    students.cgpa,
    students.skills,
    jobs.job_id, 
    jobs.title, 
    applications.status::TEXT AS status,
    COALESCE(interviews.status::TEXT, '') AS interview_status,
    applications.application_id
FROM applications
JOIN jobs ON applications.job_id = jobs.job_id
JOIN students ON applications.student_id = students.student_id
LEFT JOIN interviews ON applications.application_id = interviews.application_id
WHERE jobs.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
AND (jobs.job_id = $2 OR $2 = 0)
AND (applications.status != 'Rejected')
ORDER BY jobs.job_id
`

type GetApplicantsParams struct {
	UserID int64
	JobID  int64
}

type GetApplicantsRow struct {
	StudentID       int64
	StudentName     string
	RollNumber      string
	Gender          string
	Department      string
	StudentEmail    string
	ContactNo       string
	Cgpa            pgtype.Float8
	Skills          pgtype.Text
	JobID           int64
	Title           string
	Status          string
	InterviewStatus interface{}
	ApplicationID   int64
}

func (q *Queries) GetApplicants(ctx context.Context, arg GetApplicantsParams) ([]GetApplicantsRow, error) {
	rows, err := q.db.Query(ctx, getApplicants, arg.UserID, arg.JobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicantsRow
	for rows.Next() {
		var i GetApplicantsRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
			&i.Gender,
			&i.Department,
			&i.StudentEmail,
			&i.ContactNo,
			&i.Cgpa,
			&i.Skills,
			&i.JobID,
			&i.Title,
			&i.Status,
			&i.InterviewStatus,
			&i.ApplicationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInterviewsForUserID = `-- name: GetInterviewsForUserID :many
WITH cte AS (
    SELECT 
        students.student_id
    FROM students
    WHERE students.user_id = $1
)
SELECT  
    companies.company_name,
    jobs.title,
    interviews.interview_id,
    (interviews.date_time)::DATE AS date,
    (interviews.date_time)::TIME::TEXT AS time,
    interviews.type::TEXT,
    interviews.location,
    interviews.notes
FROM applications
JOIN cte ON applications.student_id = cte.student_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN interviews ON interviews.application_id = applications.application_id
JOIN companies ON interviews.company_id = companies.company_id
`

type GetInterviewsForUserIDRow struct {
	CompanyName    string
	Title          string
	InterviewID    int64
	Date           pgtype.Date
	Time           string
	InterviewsType string
	Location       string
	Notes          pgtype.Text
}

func (q *Queries) GetInterviewsForUserID(ctx context.Context, userID int64) ([]GetInterviewsForUserIDRow, error) {
	rows, err := q.db.Query(ctx, getInterviewsForUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInterviewsForUserIDRow
	for rows.Next() {
		var i GetInterviewsForUserIDRow
		if err := rows.Scan(
			&i.CompanyName,
			&i.Title,
			&i.InterviewID,
			&i.Date,
			&i.Time,
			&i.InterviewsType,
			&i.Location,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobDetails = `-- name: GetJobDetails :one
SELECT 
    jobs.title,
    companies.company_name
FROM jobs 
JOIN companies ON jobs.company_id = companies.company_id
WHERE jobs.job_id = $1
`

type GetJobDetailsRow struct {
	Title       string
	CompanyName string
}

func (q *Queries) GetJobDetails(ctx context.Context, jobID int64) (GetJobDetailsRow, error) {
	row := q.db.QueryRow(ctx, getJobDetails, jobID)
	var i GetJobDetailsRow
	err := row.Scan(&i.Title, &i.CompanyName)
	return i, err
}

const getJobListings = `-- name: GetJobListings :many
SELECT 
    jobs.job_id,
    jobs.created_at::DATE as created_at,
    jobs.title,
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.skills,
    jobs.position,
    jobs.active_status,
    COALESCE(t.no_of_applications, 0)    
FROM jobs
LEFT JOIN (
    SELECT 
        job_id, 
        COUNT(job_id) AS no_of_applications 
    FROM applications 
    WHERE status != 'Rejected' 
    GROUP BY job_id ) AS t
ON jobs.job_id = t.job_id
WHERE jobs.company_id = (
    SELECT 
        companies.company_id 
    FROM companies 
    WHERE companies.user_id = $1)
`

type GetJobListingsRow struct {
	JobID            int64
	CreatedAt        pgtype.Date
	Title            string
	Location         string
	Type             string
	Salary           string
	Skills           []string
	Position         string
	ActiveStatus     bool
	NoOfApplications int64
}

func (q *Queries) GetJobListings(ctx context.Context, userID int64) ([]GetJobListingsRow, error) {
	rows, err := q.db.Query(ctx, getJobListings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobListingsRow
	for rows.Next() {
		var i GetJobListingsRow
		if err := rows.Scan(
			&i.JobID,
			&i.CreatedAt,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Skills,
			&i.Position,
			&i.ActiveStatus,
			&i.NoOfApplications,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyApplicationsStatusFilter = `-- name: GetMyApplicationsStatusFilter :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    companies.company_name,
    companies.representative_email,
    companies.representative_name,
    applications.status::TEXT AS status
FROM applications
JOIN students ON applications.student_id = students.student_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE students.user_id = $1 
  AND ($2 = 'All' OR applications.status::TEXT = $2)
ORDER BY jobs.job_id
`

type GetMyApplicationsStatusFilterParams struct {
	UserID  int64
	Column2 interface{}
}

type GetMyApplicationsStatusFilterRow struct {
	JobID               int64
	Title               string
	Location            string
	Type                string
	Salary              string
	Position            string
	Skills              []string
	CompanyID           int64
	CompanyName         string
	RepresentativeEmail string
	RepresentativeName  string
	Status              string
}

func (q *Queries) GetMyApplicationsStatusFilter(ctx context.Context, arg GetMyApplicationsStatusFilterParams) ([]GetMyApplicationsStatusFilterRow, error) {
	rows, err := q.db.Query(ctx, getMyApplicationsStatusFilter, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyApplicationsStatusFilterRow
	for rows.Next() {
		var i GetMyApplicationsStatusFilterRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.CompanyName,
			&i.RepresentativeEmail,
			&i.RepresentativeName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferLetterData = `-- name: GetOfferLetterData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name,
    c.representative_contact,
    c.representative_email
FROM students
JOIN (SELECT job_id, student_id FROM applications WHERE application_id = $1) AS t ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name, representative_contact, representative_email FROM companies) AS c ON j.company_id = c.company_id
`

type GetOfferLetterDataRow struct {
	StudentName           string
	StudentEmail          string
	Title                 string
	CompanyName           string
	RepresentativeContact string
	RepresentativeEmail   string
}

func (q *Queries) GetOfferLetterData(ctx context.Context, applicationID int64) (GetOfferLetterDataRow, error) {
	row := q.db.QueryRow(ctx, getOfferLetterData, applicationID)
	var i GetOfferLetterDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
		&i.RepresentativeContact,
		&i.RepresentativeEmail,
	)
	return i, err
}

const getResumeAndResultPath = `-- name: GetResumeAndResultPath :one
SELECT 
    resume_url, 
    result_url
FROM students 
JOIN applications 
ON applications.student_id = students.student_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.application_id = $1
AND companies.user_id = $2
`

type GetResumeAndResultPathParams struct {
	ApplicationID int64
	UserID        int64
}

type GetResumeAndResultPathRow struct {
	ResumeUrl pgtype.Text
	ResultUrl string
}

func (q *Queries) GetResumeAndResultPath(ctx context.Context, arg GetResumeAndResultPathParams) (GetResumeAndResultPathRow, error) {
	row := q.db.QueryRow(ctx, getResumeAndResultPath, arg.ApplicationID, arg.UserID)
	var i GetResumeAndResultPathRow
	err := row.Scan(&i.ResumeUrl, &i.ResultUrl)
	return i, err
}

const getScheduleInterviewData = `-- name: GetScheduleInterviewData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name
FROM students
JOIN (SELECT job_id, student_id FROM applications WHERE application_id = $1) AS t ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name FROM companies) AS c ON j.company_id = c.company_id
`

type GetScheduleInterviewDataRow struct {
	StudentName  string
	StudentEmail string
	Title        string
	CompanyName  string
}

func (q *Queries) GetScheduleInterviewData(ctx context.Context, applicationID int64) (GetScheduleInterviewDataRow, error) {
	row := q.db.QueryRow(ctx, getScheduleInterviewData, applicationID)
	var i GetScheduleInterviewDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
	)
	return i, err
}

const getTestsForUserID = `-- name: GetTestsForUserID :many
WITH cte AS (
    SELECT  
        applications.job_id,
        jobs.title
    FROM applications
    JOIN jobs ON applications.job_id = jobs.job_id
    WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
)
SELECT 
    tests.test_id,
    tests.test_name,
    tests.description,
    tests.duration,
    tests.q_count,
    TO_CHAR(tests.end_time, 'YYYY-MM-DD HH24:MI:SS') AS end_time,
    tests.type,    
    companies.company_name,
    cte.title
FROM tests
JOIN cte ON tests.job_id = cte.job_id
JOIN companies ON tests.company_id = companies.company_id
WHERE tests.test_id = $2 OR ($2 = 0)
`

type GetTestsForUserIDParams struct {
	UserID int64
	TestID int64
}

type GetTestsForUserIDRow struct {
	TestID      int64
	TestName    string
	Description pgtype.Text
	Duration    int64
	QCount      int64
	EndTime     string
	Type        string
	CompanyName string
	Title       string
}

func (q *Queries) GetTestsForUserID(ctx context.Context, arg GetTestsForUserIDParams) ([]GetTestsForUserIDRow, error) {
	rows, err := q.db.Query(ctx, getTestsForUserID, arg.UserID, arg.TestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestsForUserIDRow
	for rows.Next() {
		var i GetTestsForUserIDRow
		if err := rows.Scan(
			&i.TestID,
			&i.TestName,
			&i.Description,
			&i.Duration,
			&i.QCount,
			&i.EndTime,
			&i.Type,
			&i.CompanyName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserData = `-- name: GetUserData :one
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users WHERE email = $1
`

func (q *Queries) GetUserData(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserData, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const getUserIDCompanyIDJobIDApplicationID = `-- name: GetUserIDCompanyIDJobIDApplicationID :one
SELECT 
    companies.user_id
FROM companies
JOIN jobs ON jobs.company_id = companies.company_id
JOIN applications ON applications.job_id = jobs.job_id
WHERE applications.application_id = $1
`

func (q *Queries) GetUserIDCompanyIDJobIDApplicationID(ctx context.Context, applicationID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDCompanyIDJobIDApplicationID, applicationID)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const insertNewApplication = `-- name: InsertNewApplication :exec
INSERT INTO applications (job_id, student_id, data_url) 
VALUES ($1, (SELECT student_id FROM students WHERE user_id = $2), $3)
`

type InsertNewApplicationParams struct {
	JobID   int64
	UserID  int64
	DataUrl pgtype.Text
}

func (q *Queries) InsertNewApplication(ctx context.Context, arg InsertNewApplicationParams) error {
	_, err := q.db.Exec(ctx, insertNewApplication, arg.JobID, arg.UserID, arg.DataUrl)
	return err
}

const insertNewJob = `-- name: InsertNewJob :one

INSERT INTO jobs (data_url, company_id, title, location, type, salary, skills, position, extras)
VALUES ($1, (SELECT company_id FROM companies WHERE representative_email = $2), $3, $4, $5, $6, $7, $8, $9)
RETURNING job_id, data_url, created_at, company_id, title, location, type, salary, skills, position, extras, active_status
`

type InsertNewJobParams struct {
	DataUrl             pgtype.Text
	RepresentativeEmail string
	Title               string
	Location            string
	Type                string
	Salary              string
	Skills              []string
	Position            string
	Extras              []byte
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Company queries
func (q *Queries) InsertNewJob(ctx context.Context, arg InsertNewJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, insertNewJob,
		arg.DataUrl,
		arg.RepresentativeEmail,
		arg.Title,
		arg.Location,
		arg.Type,
		arg.Salary,
		arg.Skills,
		arg.Position,
		arg.Extras,
	)
	var i Job
	err := row.Scan(
		&i.JobID,
		&i.DataUrl,
		&i.CreatedAt,
		&i.CompanyID,
		&i.Title,
		&i.Location,
		&i.Type,
		&i.Salary,
		&i.Skills,
		&i.Position,
		&i.Extras,
		&i.ActiveStatus,
	)
	return i, err
}

const interviewStatusTo = `-- name: InterviewStatusTo :exec
UPDATE interviews
SET status = $1
WHERE application_id = $2
`

type InterviewStatusToParams struct {
	Status        interface{}
	ApplicationID int64
}

func (q *Queries) InterviewStatusTo(ctx context.Context, arg InterviewStatusToParams) error {
	_, err := q.db.Exec(ctx, interviewStatusTo, arg.Status, arg.ApplicationID)
	return err
}

const newTest = `-- name: NewTest :exec
INSERT INTO tests (test_name, description, duration, q_count, end_time, type, upload_method, job_id, company_id, file_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, (SELECT company_id FROM companies WHERE user_id = $9), $10)
`

type NewTestParams struct {
	TestName     string
	Description  pgtype.Text
	Duration     int64
	QCount       int64
	EndTime      pgtype.Timestamptz
	Type         string
	UploadMethod interface{}
	JobID        pgtype.Int8
	UserID       int64
	FileID       string
}

func (q *Queries) NewTest(ctx context.Context, arg NewTestParams) error {
	_, err := q.db.Exec(ctx, newTest,
		arg.TestName,
		arg.Description,
		arg.Duration,
		arg.QCount,
		arg.EndTime,
		arg.Type,
		arg.UploadMethod,
		arg.JobID,
		arg.UserID,
		arg.FileID,
	)
	return err
}

const newTestResult = `-- name: NewTestResult :exec
INSERT INTO testResults (test_id, user_id)
VALUES ($1, $2)
`

type NewTestResultParams struct {
	TestID int64
	UserID int64
}

func (q *Queries) NewTestResult(ctx context.Context, arg NewTestResultParams) error {
	_, err := q.db.Exec(ctx, newTestResult, arg.TestID, arg.UserID)
	return err
}

const scheduleInterview = `-- name: ScheduleInterview :exec
INSERT INTO interviews (application_id, company_id, date_time, type, notes, location)
VALUES ($1, (SELECT company_id FROM companies WHERE user_id = $2), $3, $4, $5, $6)
`

type ScheduleInterviewParams struct {
	ApplicationID int64
	UserID        int64
	DateTime      pgtype.Timestamptz
	Type          interface{}
	Notes         pgtype.Text
	Location      string
}

func (q *Queries) ScheduleInterview(ctx context.Context, arg ScheduleInterviewParams) error {
	_, err := q.db.Exec(ctx, scheduleInterview,
		arg.ApplicationID,
		arg.UserID,
		arg.DateTime,
		arg.Type,
		arg.Notes,
		arg.Location,
	)
	return err
}

const signupUser = `-- name: SignupUser :one
INSERT INTO users (email, password, role) VALUES ($1, $2, $3)
RETURNING user_id, email, password, role, user_uuid, created_at, confirmed, is_verified
`

type SignupUserParams struct {
	Email    string
	Password string
	Role     int64
}

func (q *Queries) SignupUser(ctx context.Context, arg SignupUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signupUser, arg.Email, arg.Password, arg.Role)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const takeTest = `-- name: TakeTest :one
SELECT 
    tests.file_id,
    tests.duration
FROM tests
JOIN applications ON applications.job_id = tests.job_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE user_id = $1)
AND tests.test_id = $2
`

type TakeTestParams struct {
	UserID int64
	TestID int64
}

type TakeTestRow struct {
	FileID   string
	Duration int64
}

func (q *Queries) TakeTest(ctx context.Context, arg TakeTestParams) (TakeTestRow, error) {
	row := q.db.QueryRow(ctx, takeTest, arg.UserID, arg.TestID)
	var i TakeTestRow
	err := row.Scan(&i.FileID, &i.Duration)
	return i, err
}

const updateEmailConfirmation = `-- name: UpdateEmailConfirmation :exec
UPDATE users
SET confirmed = true
WHERE email = $1
`

func (q *Queries) UpdateEmailConfirmation(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, updateEmailConfirmation, email)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password = $2
WHERE email = $1
`

type UpdatePasswordParams struct {
	Email    string
	Password string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.Email, arg.Password)
	return err
}
