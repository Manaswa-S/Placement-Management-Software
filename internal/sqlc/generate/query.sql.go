// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const applicationStatusTo = `-- name: ApplicationStatusTo :exec
UPDATE applications
SET status = $1
WHERE job_id = $2 AND student_id = $3 AND status = $4
`

type ApplicationStatusToParams struct {
	Status    interface{}
	JobID     int64
	StudentID int64
	Status_2  interface{}
}

func (q *Queries) ApplicationStatusTo(ctx context.Context, arg ApplicationStatusToParams) error {
	_, err := q.db.Exec(ctx, applicationStatusTo,
		arg.Status,
		arg.JobID,
		arg.StudentID,
		arg.Status_2,
	)
	return err
}

const applicationStatusToRejected = `-- name: ApplicationStatusToRejected :exec
UPDATE applications
SET status = $1
WHERE job_id = $2 AND student_id = $3
`

type ApplicationStatusToRejectedParams struct {
	Status    interface{}
	JobID     int64
	StudentID int64
}

func (q *Queries) ApplicationStatusToRejected(ctx context.Context, arg ApplicationStatusToRejectedParams) error {
	_, err := q.db.Exec(ctx, applicationStatusToRejected, arg.Status, arg.JobID, arg.StudentID)
	return err
}

const cancelApplication = `-- name: CancelApplication :exec
DELETE FROM applications 
WHERE student_id = (SELECT student_id FROM students WHERE students.user_id = $1) 
AND job_id = $2
`

type CancelApplicationParams struct {
	UserID int64
	JobID  int64
}

func (q *Queries) CancelApplication(ctx context.Context, arg CancelApplicationParams) error {
	_, err := q.db.Exec(ctx, cancelApplication, arg.UserID, arg.JobID)
	return err
}

const closeJob = `-- name: CloseJob :exec
UPDATE jobs
SET active_status = false
WHERE jobs.job_id = $1 
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type CloseJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) CloseJob(ctx context.Context, arg CloseJobParams) error {
	_, err := q.db.Exec(ctx, closeJob, arg.JobID, arg.UserID)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs 
WHERE jobs.job_id = $1
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type DeleteJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) DeleteJob(ctx context.Context, arg DeleteJobParams) error {
	_, err := q.db.Exec(ctx, deleteJob, arg.JobID, arg.UserID)
	return err
}

const extraInfoCompany = `-- name: ExtraInfoCompany :one
INSERT INTO companies (company_name, representative_email, representative_contact, representative_name, data_url, user_id)
VALUES ($1, $2, $3, $4, $5, (SELECT user_id FROM users WHERE email = $6))
RETURNING company_id, company_name, representative_email, representative_contact, representative_name, data_url, user_id
`

type ExtraInfoCompanyParams struct {
	CompanyName           string
	RepresentativeEmail   string
	RepresentativeContact string
	RepresentativeName    string
	DataUrl               pgtype.Text
	Email                 string
}

func (q *Queries) ExtraInfoCompany(ctx context.Context, arg ExtraInfoCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, extraInfoCompany,
		arg.CompanyName,
		arg.RepresentativeEmail,
		arg.RepresentativeContact,
		arg.RepresentativeName,
		arg.DataUrl,
		arg.Email,
	)
	var i Company
	err := row.Scan(
		&i.CompanyID,
		&i.CompanyName,
		&i.RepresentativeEmail,
		&i.RepresentativeContact,
		&i.RepresentativeName,
		&i.DataUrl,
		&i.UserID,
	)
	return i, err
}

const extraInfoStudent = `-- name: ExtraInfoStudent :one
INSERT INTO students (student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, (SELECT user_id FROM users WHERE email = $15), $16)
RETURNING student_id, student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras
`

type ExtraInfoStudentParams struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	ResumeUrl    pgtype.Text
	ResultUrl    string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Email        string
	Extras       []byte
}

func (q *Queries) ExtraInfoStudent(ctx context.Context, arg ExtraInfoStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, extraInfoStudent,
		arg.StudentName,
		arg.RollNumber,
		arg.StudentDob,
		arg.Gender,
		arg.Course,
		arg.Department,
		arg.YearOfStudy,
		arg.ResumeUrl,
		arg.ResultUrl,
		arg.Cgpa,
		arg.ContactNo,
		arg.StudentEmail,
		arg.Address,
		arg.Skills,
		arg.Email,
		arg.Extras,
	)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.ResumeUrl,
		&i.ResultUrl,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.UserID,
		&i.Extras,
	)
	return i, err
}

const getAll = `-- name: GetAll :many
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users
`

func (q *Queries) GetAll(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.UserUuid,
			&i.CreatedAt,
			&i.Confirmed,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicableJobs = `-- name: GetApplicableJobs :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    jobs.active_status,
    companies.company_name 
FROM jobs
JOIN companies ON jobs.company_id = companies.company_id 
LEFT JOIN (SELECT applications.job_id FROM applications WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)) AS t 
ON jobs.job_id = t.job_id
WHERE t.job_id IS NULL
`

type GetApplicableJobsRow struct {
	JobID        int64
	Title        string
	Location     string
	Type         string
	Salary       string
	Position     string
	Skills       []string
	CompanyID    int64
	ActiveStatus bool
	CompanyName  string
}

func (q *Queries) GetApplicableJobs(ctx context.Context, userID int64) ([]GetApplicableJobsRow, error) {
	rows, err := q.db.Query(ctx, getApplicableJobs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicableJobsRow
	for rows.Next() {
		var i GetApplicableJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.ActiveStatus,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicants = `-- name: GetApplicants :many
SELECT
    students.student_id,
    students.student_name,
    students.roll_number,
    students.gender,
    students.department,
    students.student_email,
    students.contact_no,
    students.cgpa,
    students.skills,
    jobs.job_id, 
    jobs.title, 
    applications.status::TEXT AS status,
    COALESCE(interviews.status::TEXT, '') AS interview_status
FROM applications
JOIN jobs ON applications.job_id = jobs.job_id
JOIN students ON applications.student_id = students.student_id
LEFT JOIN interviews ON applications.student_id = interviews.student_id AND applications.job_id = interviews.job_id
WHERE jobs.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
AND (jobs.job_id = $2 OR $2 = 0)
`

type GetApplicantsParams struct {
	UserID int64
	JobID  int64
}

type GetApplicantsRow struct {
	StudentID       int64
	StudentName     string
	RollNumber      string
	Gender          string
	Department      string
	StudentEmail    string
	ContactNo       string
	Cgpa            pgtype.Float8
	Skills          pgtype.Text
	JobID           int64
	Title           string
	Status          string
	InterviewStatus interface{}
}

func (q *Queries) GetApplicants(ctx context.Context, arg GetApplicantsParams) ([]GetApplicantsRow, error) {
	rows, err := q.db.Query(ctx, getApplicants, arg.UserID, arg.JobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicantsRow
	for rows.Next() {
		var i GetApplicantsRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
			&i.Gender,
			&i.Department,
			&i.StudentEmail,
			&i.ContactNo,
			&i.Cgpa,
			&i.Skills,
			&i.JobID,
			&i.Title,
			&i.Status,
			&i.InterviewStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobListings = `-- name: GetJobListings :many
SELECT 
    jobs.job_id,
    jobs.created_at::DATE as created_at,
    jobs.title,
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.skills,
    jobs.position,
    jobs.active_status,
    COALESCE(t.no_of_applications, 0)    
FROM jobs
LEFT JOIN (SELECT job_id, COUNT(job_id) AS no_of_applications FROM applications GROUP BY job_id) AS t
ON jobs.job_id = t.job_id
WHERE jobs.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
`

type GetJobListingsRow struct {
	JobID            int64
	CreatedAt        pgtype.Date
	Title            string
	Location         string
	Type             string
	Salary           string
	Skills           []string
	Position         string
	ActiveStatus     bool
	NoOfApplications int64
}

func (q *Queries) GetJobListings(ctx context.Context, userID int64) ([]GetJobListingsRow, error) {
	rows, err := q.db.Query(ctx, getJobListings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobListingsRow
	for rows.Next() {
		var i GetJobListingsRow
		if err := rows.Scan(
			&i.JobID,
			&i.CreatedAt,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Skills,
			&i.Position,
			&i.ActiveStatus,
			&i.NoOfApplications,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyApplications = `-- name: GetMyApplications :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    companies.company_name,
    companies.representative_email,
    companies.representative_name,
    t.status::TEXT AS status
FROM jobs
JOIN (SELECT applications.job_id, applications.status FROM applications WHERE student_id = (
    SELECT student_id FROM students WHERE students.user_id = $1)) AS t 
ON jobs.job_id = t.job_id
JOIN companies ON jobs.company_id = companies.company_id
`

type GetMyApplicationsRow struct {
	JobID               int64
	Title               string
	Location            string
	Type                string
	Salary              string
	Position            string
	Skills              []string
	CompanyID           int64
	CompanyName         string
	RepresentativeEmail string
	RepresentativeName  string
	Status              string
}

func (q *Queries) GetMyApplications(ctx context.Context, userID int64) ([]GetMyApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getMyApplications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyApplicationsRow
	for rows.Next() {
		var i GetMyApplicationsRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.CompanyName,
			&i.RepresentativeEmail,
			&i.RepresentativeName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResumePath = `-- name: GetResumePath :one
SELECT resume_url, result_url FROM students WHERE student_id = $1
`

type GetResumePathRow struct {
	ResumeUrl pgtype.Text
	ResultUrl string
}

func (q *Queries) GetResumePath(ctx context.Context, studentID int64) (GetResumePathRow, error) {
	row := q.db.QueryRow(ctx, getResumePath, studentID)
	var i GetResumePathRow
	err := row.Scan(&i.ResumeUrl, &i.ResultUrl)
	return i, err
}

const getUserData = `-- name: GetUserData :one
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users WHERE email = $1
`

func (q *Queries) GetUserData(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserData, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const insertNewApplication = `-- name: InsertNewApplication :exec
INSERT INTO applications (job_id, student_id, data_url) 
VALUES ($1, (SELECT student_id FROM students WHERE user_id = $2), $3)
`

type InsertNewApplicationParams struct {
	JobID   int64
	UserID  int64
	DataUrl pgtype.Text
}

func (q *Queries) InsertNewApplication(ctx context.Context, arg InsertNewApplicationParams) error {
	_, err := q.db.Exec(ctx, insertNewApplication, arg.JobID, arg.UserID, arg.DataUrl)
	return err
}

const insertNewJob = `-- name: InsertNewJob :one

INSERT INTO jobs (data_url, company_id, title, location, type, salary, skills, position, extras)
VALUES ($1, (SELECT company_id FROM companies WHERE representative_email = $2), $3, $4, $5, $6, $7, $8, $9)
RETURNING job_id, data_url, created_at, company_id, title, location, type, salary, skills, position, extras, active_status
`

type InsertNewJobParams struct {
	DataUrl             pgtype.Text
	RepresentativeEmail string
	Title               string
	Location            string
	Type                string
	Salary              string
	Skills              []string
	Position            string
	Extras              []byte
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Company queries
func (q *Queries) InsertNewJob(ctx context.Context, arg InsertNewJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, insertNewJob,
		arg.DataUrl,
		arg.RepresentativeEmail,
		arg.Title,
		arg.Location,
		arg.Type,
		arg.Salary,
		arg.Skills,
		arg.Position,
		arg.Extras,
	)
	var i Job
	err := row.Scan(
		&i.JobID,
		&i.DataUrl,
		&i.CreatedAt,
		&i.CompanyID,
		&i.Title,
		&i.Location,
		&i.Type,
		&i.Salary,
		&i.Skills,
		&i.Position,
		&i.Extras,
		&i.ActiveStatus,
	)
	return i, err
}

const interviewStatusTo = `-- name: InterviewStatusTo :exec
UPDATE interviews
SET status = $1
WHERE job_id = $2 AND student_id = $3
`

type InterviewStatusToParams struct {
	Status    interface{}
	JobID     int64
	StudentID int64
}

func (q *Queries) InterviewStatusTo(ctx context.Context, arg InterviewStatusToParams) error {
	_, err := q.db.Exec(ctx, interviewStatusTo, arg.Status, arg.JobID, arg.StudentID)
	return err
}

const scheduleInterview = `-- name: ScheduleInterview :one
INSERT INTO interviews (job_id, student_id, company_id, date, time, type, notes)
VALUES ($1, $2, (SELECT company_id FROM companies WHERE user_id = $3), $4, $5, $6, $7)
RETURNING job_id, student_id, company_id, date, TO_CHAR(time, 'hh:mi AM'), type::TEXT AS type, notes
`

type ScheduleInterviewParams struct {
	JobID     int64
	StudentID int64
	UserID    int64
	Date      pgtype.Date
	Time      pgtype.Time
	Type      interface{}
	Notes     pgtype.Text
}

type ScheduleInterviewRow struct {
	JobID     int64
	StudentID int64
	CompanyID int64
	Date      pgtype.Date
	ToChar    string
	Type      string
	Notes     pgtype.Text
}

func (q *Queries) ScheduleInterview(ctx context.Context, arg ScheduleInterviewParams) (ScheduleInterviewRow, error) {
	row := q.db.QueryRow(ctx, scheduleInterview,
		arg.JobID,
		arg.StudentID,
		arg.UserID,
		arg.Date,
		arg.Time,
		arg.Type,
		arg.Notes,
	)
	var i ScheduleInterviewRow
	err := row.Scan(
		&i.JobID,
		&i.StudentID,
		&i.CompanyID,
		&i.Date,
		&i.ToChar,
		&i.Type,
		&i.Notes,
	)
	return i, err
}

const signupUser = `-- name: SignupUser :one
INSERT INTO users (email, password, role) VALUES ($1, $2, $3)
RETURNING user_id, email, password, role, user_uuid, created_at, confirmed, is_verified
`

type SignupUserParams struct {
	Email    string
	Password string
	Role     int64
}

func (q *Queries) SignupUser(ctx context.Context, arg SignupUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signupUser, arg.Email, arg.Password, arg.Role)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const updateEmailConfirmation = `-- name: UpdateEmailConfirmation :exec
UPDATE users
SET confirmed = true
WHERE email = $1
`

func (q *Queries) UpdateEmailConfirmation(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, updateEmailConfirmation, email)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password = $2
WHERE email = $1
`

type UpdatePasswordParams struct {
	Email    string
	Password string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.Email, arg.Password)
	return err
}
