// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const applicationHistory = `-- name: ApplicationHistory :many
SELECT 
    applications.application_id,
    TO_CHAR(applications.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    jobs.title,
    companies.company_name
FROM applications
JOIN jobs ON jobs.job_id = applications.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT students.student_id FROM students WHERE students.user_id = $1)
ORDER BY applications.created_at DESC
`

type ApplicationHistoryRow struct {
	ApplicationID int64
	CreatedAt     string
	Title         string
	CompanyName   string
}

func (q *Queries) ApplicationHistory(ctx context.Context, userID int64) ([]ApplicationHistoryRow, error) {
	rows, err := q.db.Query(ctx, applicationHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationHistoryRow
	for rows.Next() {
		var i ApplicationHistoryRow
		if err := rows.Scan(
			&i.ApplicationID,
			&i.CreatedAt,
			&i.Title,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const applicationStatusTo = `-- name: ApplicationStatusTo :exec
UPDATE applications
SET status = $1
WHERE application_id = $2
`

type ApplicationStatusToParams struct {
	Status        interface{}
	ApplicationID int64
}

func (q *Queries) ApplicationStatusTo(ctx context.Context, arg ApplicationStatusToParams) error {
	_, err := q.db.Exec(ctx, applicationStatusTo, arg.Status, arg.ApplicationID)
	return err
}

const applicationStatusToAnd = `-- name: ApplicationStatusToAnd :exec
UPDATE applications
SET status = $1
WHERE application_id = $2 AND status = $3
`

type ApplicationStatusToAndParams struct {
	Status        interface{}
	ApplicationID int64
	Status_2      interface{}
}

func (q *Queries) ApplicationStatusToAnd(ctx context.Context, arg ApplicationStatusToAndParams) error {
	_, err := q.db.Exec(ctx, applicationStatusToAnd, arg.Status, arg.ApplicationID, arg.Status_2)
	return err
}

const applicationsStatusCounts = `-- name: ApplicationsStatusCounts :one
SELECT
    CAST(COALESCE(COUNT(applications.status), 0) AS BIGINT) AS applied_count,
    CAST(COALESCE(SUM(CASE WHEN applications.status = 'UnderReview' THEN 1 END), 0) AS BIGINT) AS under_review_count,
    CAST(COALESCE(SUM(CASE WHEN applications.status = 'ShortListed' THEN 1 END), 0) AS BIGINT) AS shortlisted_count,
    CAST(COALESCE(SUM(CASE WHEN applications.status = 'Rejected' THEN 1 END), 0) AS BIGINT) AS rejected_count,
    CAST(COALESCE(SUM(CASE WHEN applications.status = 'Offered' THEN 1 END), 0) AS BIGINT) AS offered_count,
    CAST(COALESCE(SUM(CASE WHEN applications.status = 'Hired' THEN 1 END), 0) AS BIGINT) AS hired_count
FROM applications
WHERE applications.student_id = (SELECT students.student_id FROM students WHERE students.user_id = $1)
`

type ApplicationsStatusCountsRow struct {
	AppliedCount     int64
	UnderReviewCount int64
	ShortlistedCount int64
	RejectedCount    int64
	OfferedCount     int64
	HiredCount       int64
}

func (q *Queries) ApplicationsStatusCounts(ctx context.Context, userID int64) (ApplicationsStatusCountsRow, error) {
	row := q.db.QueryRow(ctx, applicationsStatusCounts, userID)
	var i ApplicationsStatusCountsRow
	err := row.Scan(
		&i.AppliedCount,
		&i.UnderReviewCount,
		&i.ShortlistedCount,
		&i.RejectedCount,
		&i.OfferedCount,
		&i.HiredCount,
	)
	return i, err
}

const cancelApplication = `-- name: CancelApplication :exec
DELETE FROM applications 
WHERE student_id = (SELECT student_id FROM students WHERE students.user_id = $1) 
AND job_id = $2
`

type CancelApplicationParams struct {
	UserID int64
	JobID  int64
}

func (q *Queries) CancelApplication(ctx context.Context, arg CancelApplicationParams) error {
	_, err := q.db.Exec(ctx, cancelApplication, arg.UserID, arg.JobID)
	return err
}

const cancelInterviewEmailData = `-- name: CancelInterviewEmailData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name,
    TO_CHAR(t.date_time, 'HH12:MI AM DD-MM-YYYY') AS date_time,
    c.representative_name,
    c.representative_email
FROM students
JOIN (
    SELECT 
        job_id, 
        student_id, 
        interviews.date_time
    FROM applications 
    JOIN interviews ON interviews.application_id = applications.application_id 
    WHERE applications.application_id = $1) AS t 
ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name, representative_name, representative_email FROM companies) AS c ON j.company_id = c.company_id
`

type CancelInterviewEmailDataRow struct {
	StudentName         string
	StudentEmail        string
	Title               string
	CompanyName         string
	DateTime            string
	RepresentativeName  string
	RepresentativeEmail string
}

func (q *Queries) CancelInterviewEmailData(ctx context.Context, applicationID int64) (CancelInterviewEmailDataRow, error) {
	row := q.db.QueryRow(ctx, cancelInterviewEmailData, applicationID)
	var i CancelInterviewEmailDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
		&i.DateTime,
		&i.RepresentativeName,
		&i.RepresentativeEmail,
	)
	return i, err
}

const clearAnswersTable = `-- name: ClearAnswersTable :exec
DELETE FROM temp_correct_answers
`

func (q *Queries) ClearAnswersTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearAnswersTable)
	return err
}

const closeJob = `-- name: CloseJob :exec
UPDATE jobs
SET active_status = false
WHERE jobs.job_id = $1 
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type CloseJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) CloseJob(ctx context.Context, arg CloseJobParams) error {
	_, err := q.db.Exec(ctx, closeJob, arg.JobID, arg.UserID)
	return err
}

const companyDashboardData = `-- name: CompanyDashboardData :one
WITH company AS (
    SELECT company_id FROM companies WHERE user_id = $1
),
jc AS (
    SELECT COUNT(jobs.job_id) AS jobs_count
    FROM jobs
    WHERE jobs.company_id = (SELECT company_id FROM company)
),
ac AS (
    SELECT COUNT(applications.application_id) AS applications_count
    FROM applications
    JOIN jobs ON applications.job_id = jobs.job_id
    WHERE jobs.company_id = (SELECT company_id FROM company)
)
SELECT jobs_count, applications_count 
FROM jc
CROSS JOIN ac
`

type CompanyDashboardDataRow struct {
	JobsCount         int64
	ApplicationsCount int64
}

func (q *Queries) CompanyDashboardData(ctx context.Context, userID int64) (CompanyDashboardDataRow, error) {
	row := q.db.QueryRow(ctx, companyDashboardData, userID)
	var i CompanyDashboardDataRow
	err := row.Scan(&i.JobsCount, &i.ApplicationsCount)
	return i, err
}

const completedInterviewsCompany = `-- name: CompletedInterviewsCompany :many
SELECT 
    students.student_name,
    students.student_id,
    interviews.interview_id,
    interviews.application_id,
    TO_CHAR(interviews.date_time, 'HH12:MI AM DD-MM-YYYY') AS date_time,
    interviews.extras
FROM interviews
JOIN applications ON interviews.application_id = applications.application_id
JOIN students ON students.student_id = applications.student_id
WHERE interviews.company_id = (SELECT company_id FROM companies WHERE companies.user_id = $1)
AND interviews.status = 'Completed'
`

type CompletedInterviewsCompanyRow struct {
	StudentName   string
	StudentID     int64
	InterviewID   int64
	ApplicationID int64
	DateTime      string
	Extras        []byte
}

func (q *Queries) CompletedInterviewsCompany(ctx context.Context, userID int64) ([]CompletedInterviewsCompanyRow, error) {
	rows, err := q.db.Query(ctx, completedInterviewsCompany, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompletedInterviewsCompanyRow
	for rows.Next() {
		var i CompletedInterviewsCompanyRow
		if err := rows.Scan(
			&i.StudentName,
			&i.StudentID,
			&i.InterviewID,
			&i.ApplicationID,
			&i.DateTime,
			&i.Extras,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const completedInterviewsStudent = `-- name: CompletedInterviewsStudent :many
SELECT 
    jobs.title,
    companies.company_name,
    interviews.interview_id,
    interviews.application_id,
    TO_CHAR(interviews.date_time, 'HH12:MI AM DD-MM-YYYY') AS date_time,
    interviews.extras
FROM interviews
JOIN applications ON interviews.application_id = applications.application_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
AND interviews.status = 'Completed'
`

type CompletedInterviewsStudentRow struct {
	Title         string
	CompanyName   string
	InterviewID   int64
	ApplicationID int64
	DateTime      string
	Extras        []byte
}

func (q *Queries) CompletedInterviewsStudent(ctx context.Context, userID int64) ([]CompletedInterviewsStudentRow, error) {
	rows, err := q.db.Query(ctx, completedInterviewsStudent, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompletedInterviewsStudentRow
	for rows.Next() {
		var i CompletedInterviewsStudentRow
		if err := rows.Scan(
			&i.Title,
			&i.CompanyName,
			&i.InterviewID,
			&i.ApplicationID,
			&i.DateTime,
			&i.Extras,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const completedTestsCompany = `-- name: CompletedTestsCompany :many
SELECT 
    tests.test_id,
    tests.test_name,
    TO_CHAR(tests.end_time, 'HH12:MI AM DD-MM-YYYY') AS end_time,
    tests.threshold,
    tests.published,
    TO_CHAR(tests.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at
FROM tests
WHERE tests.end_time < NOW()
AND tests.company_id = (SELECT company_id FROM companies WHERE companies.user_id = $1)
`

type CompletedTestsCompanyRow struct {
	TestID    int64
	TestName  string
	EndTime   string
	Threshold int32
	Published bool
	CreatedAt string
}

func (q *Queries) CompletedTestsCompany(ctx context.Context, userID int64) ([]CompletedTestsCompanyRow, error) {
	rows, err := q.db.Query(ctx, completedTestsCompany, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompletedTestsCompanyRow
	for rows.Next() {
		var i CompletedTestsCompanyRow
		if err := rows.Scan(
			&i.TestID,
			&i.TestName,
			&i.EndTime,
			&i.Threshold,
			&i.Published,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const completedTestsStudent = `-- name: CompletedTestsStudent :many
SELECT 
    tests.test_id,
    tests.test_name,
    tests.published,

    testresults.result_id,
    TO_CHAR(testresults.start_time, 'HH12:MI AM DD-MM-YYYY') AS start_time,
    TO_CHAR(testresults.end_time, 'HH12:MI AM DD-MM-YYYY') AS end_time,

    companies.company_name,
    jobs.title
FROM testresults
JOIN tests ON testresults.test_id = tests.test_id
JOIN companies ON tests.company_id = companies.company_id
JOIN jobs ON tests.job_id = jobs.job_id
WHERE testresults.user_id = $1
AND testresults.end_time IS NOT NULL
ORDER BY testresults.result_id
`

type CompletedTestsStudentRow struct {
	TestID      int64
	TestName    string
	Published   bool
	ResultID    int64
	StartTime   string
	EndTime     string
	CompanyName string
	Title       string
}

func (q *Queries) CompletedTestsStudent(ctx context.Context, userID int64) ([]CompletedTestsStudentRow, error) {
	rows, err := q.db.Query(ctx, completedTestsStudent, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompletedTestsStudentRow
	for rows.Next() {
		var i CompletedTestsStudentRow
		if err := rows.Scan(
			&i.TestID,
			&i.TestName,
			&i.Published,
			&i.ResultID,
			&i.StartTime,
			&i.EndTime,
			&i.CompanyName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cumulativeResultData = `-- name: CumulativeResultData :many
WITH tr AS (
    SELECT 
        result_id,
        SUM(time_taken) AS total_time_taken,
        COUNT(result_id) AS questions_attempted
    FROM testresponses
    GROUP BY result_id
),
main AS (
    SELECT 
        testresults.result_id,
        testresults.user_id,
        TO_CHAR(testresults.start_time, 'HH12:MI:SS AM DD-MM-YYYY') AS start_time,
        TO_CHAR(testresults.end_time, 'HH12:MI:SS AM DD-MM-YYYY') AS end_time,
        testresults.score,
        tr.total_time_taken,
        tr.questions_attempted
    FROM testresults 
    JOIN tr ON testresults.result_id = tr.result_id
    WHERE testresults.test_id = $1
)
SELECT result_id, user_id, start_time, end_time, score, total_time_taken, questions_attempted 
FROM main
`

type CumulativeResultDataRow struct {
	ResultID           int64
	UserID             int64
	StartTime          string
	EndTime            string
	Score              pgtype.Int8
	TotalTimeTaken     int64
	QuestionsAttempted int64
}

func (q *Queries) CumulativeResultData(ctx context.Context, testID int64) ([]CumulativeResultDataRow, error) {
	rows, err := q.db.Query(ctx, cumulativeResultData, testID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CumulativeResultDataRow
	for rows.Next() {
		var i CumulativeResultDataRow
		if err := rows.Scan(
			&i.ResultID,
			&i.UserID,
			&i.StartTime,
			&i.EndTime,
			&i.Score,
			&i.TotalTimeTaken,
			&i.QuestionsAttempted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteInterview = `-- name: DeleteInterview :exec
DELETE FROM interviews
WHERE application_id = $1
`

func (q *Queries) DeleteInterview(ctx context.Context, applicationID int64) error {
	_, err := q.db.Exec(ctx, deleteInterview, applicationID)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs 
WHERE jobs.job_id = $1
AND jobs.company_id = (SELECT companies.company_id FROM companies WHERE user_id = $2)
`

type DeleteJobParams struct {
	JobID  int64
	UserID int64
}

func (q *Queries) DeleteJob(ctx context.Context, arg DeleteJobParams) error {
	_, err := q.db.Exec(ctx, deleteJob, arg.JobID, arg.UserID)
	return err
}

const evaluateTestResult = `-- name: EvaluateTestResult :one
WITH tr AS (
    UPDATE testresponses
    SET points = temp_correct_answers.points
    FROM temp_correct_answers
    WHERE testresponses.question_id = temp_correct_answers.question_id
    AND testresponses.response = temp_correct_answers.correct_answer
    RETURNING testresponses.points, testresponses.result_id
),
rs AS (
    SELECT 
        result_id, 
        SUM(points) AS score 
    FROM tr
    GROUP BY result_id
),
up AS (
    UPDATE testresults
    SET score = rs.score
    FROM rs
    WHERE testresults.result_id = rs.result_id
)
SELECT 
    SUM(temp_correct_answers.points) AS totalpoints
FROM temp_correct_answers
`

func (q *Queries) EvaluateTestResult(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, evaluateTestResult)
	var totalpoints int64
	err := row.Scan(&totalpoints)
	return totalpoints, err
}

const extraInfoCompany = `-- name: ExtraInfoCompany :one
INSERT INTO companies (company_name, representative_email, representative_contact, representative_name, data_url, user_id)
VALUES ($1, $2, $3, $4, $5, (SELECT user_id FROM users WHERE email = $6))
RETURNING company_id, company_name, representative_email, representative_contact, representative_name, data_url, user_id
`

type ExtraInfoCompanyParams struct {
	CompanyName           string
	RepresentativeEmail   string
	RepresentativeContact string
	RepresentativeName    string
	DataUrl               pgtype.Text
	Email                 string
}

func (q *Queries) ExtraInfoCompany(ctx context.Context, arg ExtraInfoCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, extraInfoCompany,
		arg.CompanyName,
		arg.RepresentativeEmail,
		arg.RepresentativeContact,
		arg.RepresentativeName,
		arg.DataUrl,
		arg.Email,
	)
	var i Company
	err := row.Scan(
		&i.CompanyID,
		&i.CompanyName,
		&i.RepresentativeEmail,
		&i.RepresentativeContact,
		&i.RepresentativeName,
		&i.DataUrl,
		&i.UserID,
	)
	return i, err
}

const extraInfoStudent = `-- name: ExtraInfoStudent :one
INSERT INTO students (student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras, picture_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, (SELECT user_id FROM users WHERE email = $15), $16, $17)
RETURNING student_id, student_name, roll_number, student_dob, gender, course, department, year_of_study, resume_url, result_url, cgpa, contact_no, student_email, address, skills, user_id, extras, picture_url
`

type ExtraInfoStudentParams struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	ResumeUrl    pgtype.Text
	ResultUrl    string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Email        string
	Extras       []byte
	PictureUrl   pgtype.Text
}

func (q *Queries) ExtraInfoStudent(ctx context.Context, arg ExtraInfoStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, extraInfoStudent,
		arg.StudentName,
		arg.RollNumber,
		arg.StudentDob,
		arg.Gender,
		arg.Course,
		arg.Department,
		arg.YearOfStudy,
		arg.ResumeUrl,
		arg.ResultUrl,
		arg.Cgpa,
		arg.ContactNo,
		arg.StudentEmail,
		arg.Address,
		arg.Skills,
		arg.Email,
		arg.Extras,
		arg.PictureUrl,
	)
	var i Student
	err := row.Scan(
		&i.StudentID,
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.ResumeUrl,
		&i.ResultUrl,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.UserID,
		&i.Extras,
		&i.PictureUrl,
	)
	return i, err
}

const getAll = `-- name: GetAll :many
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users
`

func (q *Queries) GetAll(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.UserUuid,
			&i.CreatedAt,
			&i.Confirmed,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllApplicantsEmailsForJob = `-- name: GetAllApplicantsEmailsForJob :many
SELECT 
    students.student_email
FROM applications
JOIN students ON applications.student_id = students.student_id
WHERE applications.job_id = $1
`

func (q *Queries) GetAllApplicantsEmailsForJob(ctx context.Context, jobID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllApplicantsEmailsForJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var student_email string
		if err := rows.Scan(&student_email); err != nil {
			return nil, err
		}
		items = append(items, student_email)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFilePaths = `-- name: GetAllFilePaths :one
SELECT 
    students.resume_url,
    students.result_url,
    students.picture_url
FROM students
WHERE user_id = $1
`

type GetAllFilePathsRow struct {
	ResumeUrl  pgtype.Text
	ResultUrl  string
	PictureUrl pgtype.Text
}

func (q *Queries) GetAllFilePaths(ctx context.Context, userID int64) (GetAllFilePathsRow, error) {
	row := q.db.QueryRow(ctx, getAllFilePaths, userID)
	var i GetAllFilePathsRow
	err := row.Scan(&i.ResumeUrl, &i.ResultUrl, &i.PictureUrl)
	return i, err
}

const getApplicableJobsTypeFilter = `-- name: GetApplicableJobsTypeFilter :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    jobs.active_status,
    companies.company_name 
FROM jobs
JOIN companies ON jobs.company_id = companies.company_id 
LEFT JOIN (SELECT applications.job_id FROM applications WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)) AS t 
ON jobs.job_id = t.job_id
WHERE t.job_id IS NULL 
AND (jobs.type = $2 OR $2 = 'All')
`

type GetApplicableJobsTypeFilterParams struct {
	UserID int64
	Type   string
}

type GetApplicableJobsTypeFilterRow struct {
	JobID        int64
	Title        string
	Location     string
	Type         string
	Salary       string
	Position     string
	Skills       []string
	CompanyID    int64
	ActiveStatus bool
	CompanyName  string
}

func (q *Queries) GetApplicableJobsTypeFilter(ctx context.Context, arg GetApplicableJobsTypeFilterParams) ([]GetApplicableJobsTypeFilterRow, error) {
	rows, err := q.db.Query(ctx, getApplicableJobsTypeFilter, arg.UserID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicableJobsTypeFilterRow
	for rows.Next() {
		var i GetApplicableJobsTypeFilterRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.ActiveStatus,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicants = `-- name: GetApplicants :many
SELECT
    students.student_id,
    students.student_name,
    students.roll_number,
    students.gender,
    students.department,
    students.student_email,
    students.contact_no,
    students.cgpa,
    students.skills,
    jobs.job_id, 
    jobs.title, 
    applications.status::TEXT AS status,
    COALESCE(interviews.status::TEXT, '') AS interview_status,
    applications.application_id
FROM applications
JOIN jobs ON applications.job_id = jobs.job_id
JOIN students ON applications.student_id = students.student_id
LEFT JOIN interviews ON applications.application_id = interviews.application_id
WHERE jobs.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
AND (jobs.job_id = $2 OR $2 = 0)
AND (applications.application_id = $3 OR $3 = 0)
AND (applications.status != 'Rejected')
ORDER BY jobs.job_id
`

type GetApplicantsParams struct {
	UserID        int64
	JobID         int64
	ApplicationID int64
}

type GetApplicantsRow struct {
	StudentID       int64
	StudentName     string
	RollNumber      string
	Gender          string
	Department      string
	StudentEmail    string
	ContactNo       string
	Cgpa            pgtype.Float8
	Skills          pgtype.Text
	JobID           int64
	Title           string
	Status          string
	InterviewStatus interface{}
	ApplicationID   int64
}

func (q *Queries) GetApplicants(ctx context.Context, arg GetApplicantsParams) ([]GetApplicantsRow, error) {
	rows, err := q.db.Query(ctx, getApplicants, arg.UserID, arg.JobID, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicantsRow
	for rows.Next() {
		var i GetApplicantsRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
			&i.Gender,
			&i.Department,
			&i.StudentEmail,
			&i.ContactNo,
			&i.Cgpa,
			&i.Skills,
			&i.JobID,
			&i.Title,
			&i.Status,
			&i.InterviewStatus,
			&i.ApplicationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobDetails = `-- name: GetJobDetails :one
SELECT 
    jobs.title,
    companies.company_name
FROM jobs 
JOIN companies ON jobs.company_id = companies.company_id
WHERE jobs.job_id = $1
`

type GetJobDetailsRow struct {
	Title       string
	CompanyName string
}

func (q *Queries) GetJobDetails(ctx context.Context, jobID int64) (GetJobDetailsRow, error) {
	row := q.db.QueryRow(ctx, getJobDetails, jobID)
	var i GetJobDetailsRow
	err := row.Scan(&i.Title, &i.CompanyName)
	return i, err
}

const getJobListings = `-- name: GetJobListings :many
SELECT 
    jobs.job_id,
    jobs.created_at::DATE as created_at,
    jobs.title,
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.skills,
    jobs.position,
    jobs.active_status,
    COALESCE(t.no_of_applications, 0),
    jobs.description,
    jobs.extras    
FROM jobs
LEFT JOIN (
    SELECT 
        job_id, 
        COUNT(job_id) AS no_of_applications 
    FROM applications 
    WHERE status != 'Rejected' 
    GROUP BY job_id ) AS t
ON jobs.job_id = t.job_id
WHERE jobs.company_id = (
    SELECT 
        companies.company_id 
    FROM companies 
    WHERE companies.user_id = $1)
ORDER BY jobs.job_id
`

type GetJobListingsRow struct {
	JobID            int64
	CreatedAt        pgtype.Date
	Title            string
	Location         string
	Type             string
	Salary           string
	Skills           []string
	Position         string
	ActiveStatus     bool
	NoOfApplications int64
	Description      pgtype.Text
	Extras           []byte
}

func (q *Queries) GetJobListings(ctx context.Context, userID int64) ([]GetJobListingsRow, error) {
	rows, err := q.db.Query(ctx, getJobListings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobListingsRow
	for rows.Next() {
		var i GetJobListingsRow
		if err := rows.Scan(
			&i.JobID,
			&i.CreatedAt,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Skills,
			&i.Position,
			&i.ActiveStatus,
			&i.NoOfApplications,
			&i.Description,
			&i.Extras,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyApplicationsStatusFilter = `-- name: GetMyApplicationsStatusFilter :many
SELECT 
    jobs.job_id,
    jobs.title, 
    jobs.location,
    jobs.type,
    jobs.salary,
    jobs.position,
    jobs.skills,
    jobs.company_id,
    companies.company_name,
    companies.representative_email,
    companies.representative_name,
    applications.status::TEXT AS status
FROM applications
JOIN students ON applications.student_id = students.student_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE students.user_id = $1 
  AND ($2 = 'All' OR applications.status::TEXT = $2)
ORDER BY jobs.job_id
`

type GetMyApplicationsStatusFilterParams struct {
	UserID  int64
	Column2 interface{}
}

type GetMyApplicationsStatusFilterRow struct {
	JobID               int64
	Title               string
	Location            string
	Type                string
	Salary              string
	Position            string
	Skills              []string
	CompanyID           int64
	CompanyName         string
	RepresentativeEmail string
	RepresentativeName  string
	Status              string
}

func (q *Queries) GetMyApplicationsStatusFilter(ctx context.Context, arg GetMyApplicationsStatusFilterParams) ([]GetMyApplicationsStatusFilterRow, error) {
	rows, err := q.db.Query(ctx, getMyApplicationsStatusFilter, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyApplicationsStatusFilterRow
	for rows.Next() {
		var i GetMyApplicationsStatusFilterRow
		if err := rows.Scan(
			&i.JobID,
			&i.Title,
			&i.Location,
			&i.Type,
			&i.Salary,
			&i.Position,
			&i.Skills,
			&i.CompanyID,
			&i.CompanyName,
			&i.RepresentativeEmail,
			&i.RepresentativeName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferLetterData = `-- name: GetOfferLetterData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name,
    c.representative_contact,
    c.representative_email
FROM students
JOIN (SELECT job_id, student_id FROM applications WHERE application_id = $1) AS t ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name, representative_contact, representative_email FROM companies) AS c ON j.company_id = c.company_id
`

type GetOfferLetterDataRow struct {
	StudentName           string
	StudentEmail          string
	Title                 string
	CompanyName           string
	RepresentativeContact string
	RepresentativeEmail   string
}

func (q *Queries) GetOfferLetterData(ctx context.Context, applicationID int64) (GetOfferLetterDataRow, error) {
	row := q.db.QueryRow(ctx, getOfferLetterData, applicationID)
	var i GetOfferLetterDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
		&i.RepresentativeContact,
		&i.RepresentativeEmail,
	)
	return i, err
}

const getResumeAndResultPath = `-- name: GetResumeAndResultPath :one
SELECT 
    resume_url, 
    result_url
FROM students 
JOIN applications 
ON applications.student_id = students.student_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.application_id = $1
AND companies.user_id = $2
`

type GetResumeAndResultPathParams struct {
	ApplicationID int64
	UserID        int64
}

type GetResumeAndResultPathRow struct {
	ResumeUrl pgtype.Text
	ResultUrl string
}

func (q *Queries) GetResumeAndResultPath(ctx context.Context, arg GetResumeAndResultPathParams) (GetResumeAndResultPathRow, error) {
	row := q.db.QueryRow(ctx, getResumeAndResultPath, arg.ApplicationID, arg.UserID)
	var i GetResumeAndResultPathRow
	err := row.Scan(&i.ResumeUrl, &i.ResultUrl)
	return i, err
}

const getScheduleInterviewData = `-- name: GetScheduleInterviewData :one
SELECT 
    students.student_name, 
    students.student_email,
    j.title,
    c.company_name
FROM students
JOIN (SELECT job_id, student_id FROM applications WHERE application_id = $1) AS t ON t.student_id = students.student_id
JOIN (SELECT job_id, title, company_id FROM jobs) AS j ON j.job_id = t.job_id
JOIN (SELECT company_id, company_name FROM companies) AS c ON j.company_id = c.company_id
`

type GetScheduleInterviewDataRow struct {
	StudentName  string
	StudentEmail string
	Title        string
	CompanyName  string
}

func (q *Queries) GetScheduleInterviewData(ctx context.Context, applicationID int64) (GetScheduleInterviewDataRow, error) {
	row := q.db.QueryRow(ctx, getScheduleInterviewData, applicationID)
	var i GetScheduleInterviewDataRow
	err := row.Scan(
		&i.StudentName,
		&i.StudentEmail,
		&i.Title,
		&i.CompanyName,
	)
	return i, err
}

const getUserData = `-- name: GetUserData :one
SELECT user_id, email, password, role, user_uuid, created_at, confirmed, is_verified FROM users WHERE email = $1
`

func (q *Queries) GetUserData(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserData, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const getUserIDCompanyIDJobIDApplicationID = `-- name: GetUserIDCompanyIDJobIDApplicationID :one
SELECT 
    companies.user_id
FROM companies
JOIN jobs ON jobs.company_id = companies.company_id
JOIN applications ON applications.job_id = jobs.job_id
WHERE applications.application_id = $1
`

func (q *Queries) GetUserIDCompanyIDJobIDApplicationID(ctx context.Context, applicationID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDCompanyIDJobIDApplicationID, applicationID)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserUUIDFromEmail = `-- name: GetUserUUIDFromEmail :one
SELECT 
    users.user_uuid
FROM users 
WHERE users.email = $1
`

func (q *Queries) GetUserUUIDFromEmail(ctx context.Context, email string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getUserUUIDFromEmail, email)
	var user_uuid pgtype.UUID
	err := row.Scan(&user_uuid)
	return user_uuid, err
}

const getUserUUIDFromUserID = `-- name: GetUserUUIDFromUserID :one
SELECT 
    users.user_uuid
FROM users 
WHERE users.user_id = $1
`

func (q *Queries) GetUserUUIDFromUserID(ctx context.Context, userID int64) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getUserUUIDFromUserID, userID)
	var user_uuid pgtype.UUID
	err := row.Scan(&user_uuid)
	return user_uuid, err
}

const insertAnswers = `-- name: InsertAnswers :exec
INSERT INTO temp_correct_answers (question_id, correct_answer, points)
VALUES ($1, $2, $3)
`

type InsertAnswersParams struct {
	QuestionID    string
	CorrectAnswer []string
	Points        pgtype.Int4
}

func (q *Queries) InsertAnswers(ctx context.Context, arg InsertAnswersParams) error {
	_, err := q.db.Exec(ctx, insertAnswers, arg.QuestionID, arg.CorrectAnswer, arg.Points)
	return err
}

const insertNewApplication = `-- name: InsertNewApplication :exec
INSERT INTO applications (job_id, student_id, data_url) 
VALUES ($1, (SELECT student_id FROM students WHERE user_id = $2), $3)
`

type InsertNewApplicationParams struct {
	JobID   int64
	UserID  int64
	DataUrl pgtype.Text
}

func (q *Queries) InsertNewApplication(ctx context.Context, arg InsertNewApplicationParams) error {
	_, err := q.db.Exec(ctx, insertNewApplication, arg.JobID, arg.UserID, arg.DataUrl)
	return err
}

const insertNewJob = `-- name: InsertNewJob :exec

INSERT INTO jobs (data_url, company_id, title, location, type, salary, skills, position, extras, description)
VALUES ($1, (SELECT company_id FROM companies WHERE companies.user_id = $2), $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertNewJobParams struct {
	DataUrl     pgtype.Text
	UserID      int64
	Title       string
	Location    string
	Type        string
	Salary      string
	Skills      []string
	Position    string
	Extras      []byte
	Description pgtype.Text
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Company queries
func (q *Queries) InsertNewJob(ctx context.Context, arg InsertNewJobParams) error {
	_, err := q.db.Exec(ctx, insertNewJob,
		arg.DataUrl,
		arg.UserID,
		arg.Title,
		arg.Location,
		arg.Type,
		arg.Salary,
		arg.Skills,
		arg.Position,
		arg.Extras,
		arg.Description,
	)
	return err
}

const interviewHistory = `-- name: InterviewHistory :many
SELECT 
    interviews.interview_id,
    TO_CHAR(interviews.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    jobs.title
FROM interviews
JOIN applications ON applications.application_id = interviews.application_id
JOIN jobs ON jobs.job_id = applications.job_id
WHERE applications.student_id = (SELECT students.student_id FROM students WHERE students.user_id = $1)
ORDER BY interviews.created_at DESC
`

type InterviewHistoryRow struct {
	InterviewID int64
	CreatedAt   string
	Title       string
}

func (q *Queries) InterviewHistory(ctx context.Context, userID int64) ([]InterviewHistoryRow, error) {
	rows, err := q.db.Query(ctx, interviewHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InterviewHistoryRow
	for rows.Next() {
		var i InterviewHistoryRow
		if err := rows.Scan(&i.InterviewID, &i.CreatedAt, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const interviewStatusTo = `-- name: InterviewStatusTo :exec
UPDATE interviews
SET status = $1
WHERE application_id = $2
`

type InterviewStatusToParams struct {
	Status        interface{}
	ApplicationID int64
}

func (q *Queries) InterviewStatusTo(ctx context.Context, arg InterviewStatusToParams) error {
	_, err := q.db.Exec(ctx, interviewStatusTo, arg.Status, arg.ApplicationID)
	return err
}

const isTestGiven = `-- name: IsTestGiven :one
SELECT 
    testresults.result_id,
    testresults.test_id,
    testresults.start_time,
    testresults.end_time
FROM testresults
WHERE testresults.test_id = $1 
AND testresults.user_id = $2
`

type IsTestGivenParams struct {
	TestID int64
	UserID int64
}

type IsTestGivenRow struct {
	ResultID  int64
	TestID    int64
	StartTime pgtype.Timestamptz
	EndTime   pgtype.Timestamptz
}

func (q *Queries) IsTestGiven(ctx context.Context, arg IsTestGivenParams) (IsTestGivenRow, error) {
	row := q.db.QueryRow(ctx, isTestGiven, arg.TestID, arg.UserID)
	var i IsTestGivenRow
	err := row.Scan(
		&i.ResultID,
		&i.TestID,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const isTestPublished = `-- name: IsTestPublished :one
SELECT 
    tests.published
FROM tests
WHERE tests.test_id = $1
`

func (q *Queries) IsTestPublished(ctx context.Context, testID int64) (bool, error) {
	row := q.db.QueryRow(ctx, isTestPublished, testID)
	var published bool
	err := row.Scan(&published)
	return published, err
}

const listToVerifyStudent = `-- name: ListToVerifyStudent :many



SELECT 
    users.user_id,
    users.email,
    TO_CHAR(users.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    users.confirmed
FROM users
WHERE users.confirmed = true
AND users.is_verified = false
AND users.role = 1
`

type ListToVerifyStudentRow struct {
	UserID    int64
	Email     string
	CreatedAt string
	Confirmed bool
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Admin Functions --------------------------------
func (q *Queries) ListToVerifyStudent(ctx context.Context) ([]ListToVerifyStudentRow, error) {
	rows, err := q.db.Query(ctx, listToVerifyStudent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListToVerifyStudentRow
	for rows.Next() {
		var i ListToVerifyStudentRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.CreatedAt,
			&i.Confirmed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newTest = `-- name: NewTest :exec
INSERT INTO tests (test_name, description, duration, q_count, end_time, type, upload_method, job_id, company_id, file_id, threshold)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, (SELECT company_id FROM companies WHERE user_id = $9), $10, $11)
`

type NewTestParams struct {
	TestName     string
	Description  pgtype.Text
	Duration     int64
	QCount       int64
	EndTime      pgtype.Timestamptz
	Type         string
	UploadMethod interface{}
	JobID        pgtype.Int8
	UserID       int64
	FileID       string
	Threshold    int32
}

func (q *Queries) NewTest(ctx context.Context, arg NewTestParams) error {
	_, err := q.db.Exec(ctx, newTest,
		arg.TestName,
		arg.Description,
		arg.Duration,
		arg.QCount,
		arg.EndTime,
		arg.Type,
		arg.UploadMethod,
		arg.JobID,
		arg.UserID,
		arg.FileID,
		arg.Threshold,
	)
	return err
}

const newTestResult = `-- name: NewTestResult :exec
INSERT INTO testresults (test_id, user_id, start_time)
VALUES ($1, $2, $3)
`

type NewTestResultParams struct {
	TestID    int64
	UserID    int64
	StartTime pgtype.Timestamptz
}

func (q *Queries) NewTestResult(ctx context.Context, arg NewTestResultParams) error {
	_, err := q.db.Exec(ctx, newTestResult, arg.TestID, arg.UserID, arg.StartTime)
	return err
}

const profileData = `-- name: ProfileData :one
SELECT 
    students.student_name,
    students.roll_number,
    students.student_dob,
    students.gender,
    students.course,
    students.department,
    students.year_of_study,
    students.cgpa,
    students.contact_no,
    students.student_email,
    students.address,
    students.skills,
    students.extras
FROM students
WHERE students.user_id = $1
`

type ProfileDataRow struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Extras       []byte
}

func (q *Queries) ProfileData(ctx context.Context, userID int64) (ProfileDataRow, error) {
	row := q.db.QueryRow(ctx, profileData, userID)
	var i ProfileDataRow
	err := row.Scan(
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.Extras,
	)
	return i, err
}

const scheduleInterview = `-- name: ScheduleInterview :one
INSERT INTO interviews (application_id, company_id, date_time, type, notes, location)
VALUES ($1, (SELECT company_id FROM companies WHERE user_id = $2), $3, $4, $5, $6)
RETURNING TO_CHAR(date_time, 'HH12:MI AM DD-MM-YYYY') AS date_time
`

type ScheduleInterviewParams struct {
	ApplicationID int64
	UserID        int64
	DateTime      pgtype.Timestamptz
	Type          interface{}
	Notes         pgtype.Text
	Location      string
}

func (q *Queries) ScheduleInterview(ctx context.Context, arg ScheduleInterviewParams) (string, error) {
	row := q.db.QueryRow(ctx, scheduleInterview,
		arg.ApplicationID,
		arg.UserID,
		arg.DateTime,
		arg.Type,
		arg.Notes,
		arg.Location,
	)
	var date_time string
	err := row.Scan(&date_time)
	return date_time, err
}

const scheduledInterviewsCompany = `-- name: ScheduledInterviewsCompany :many
SELECT 
    interviews.interview_id,
    TO_CHAR(interviews.date_time, 'HH12:MI AM DD-MM-YYYY') AS date_time,
    interviews.type::TEXT,
    interviews.status::TEXT,
    interviews.notes,
    interviews.location,
    interviews.extras,
    applications.application_id,
    applications.job_id,
    students.student_id,
    students.student_name,
    students.roll_number
FROM interviews
JOIN applications ON interviews.application_id = applications.application_id
JOIN students ON applications.student_id = students.student_id
WHERE interviews.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
AND interviews.status = 'Scheduled' AND interviews.date_time > NOW()
ORDER BY interviews.date_time
`

type ScheduledInterviewsCompanyRow struct {
	InterviewID      int64
	DateTime         string
	InterviewsType   string
	InterviewsStatus string
	Notes            pgtype.Text
	Location         string
	Extras           []byte
	ApplicationID    int64
	JobID            int64
	StudentID        int64
	StudentName      string
	RollNumber       string
}

func (q *Queries) ScheduledInterviewsCompany(ctx context.Context, userID int64) ([]ScheduledInterviewsCompanyRow, error) {
	rows, err := q.db.Query(ctx, scheduledInterviewsCompany, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledInterviewsCompanyRow
	for rows.Next() {
		var i ScheduledInterviewsCompanyRow
		if err := rows.Scan(
			&i.InterviewID,
			&i.DateTime,
			&i.InterviewsType,
			&i.InterviewsStatus,
			&i.Notes,
			&i.Location,
			&i.Extras,
			&i.ApplicationID,
			&i.JobID,
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduledTestsCompany = `-- name: ScheduledTestsCompany :many
SELECT 
    tests.test_id,
    tests.test_name,
    tests.description,
    tests.duration,
    tests.q_count,
    TO_CHAR(tests.end_time, 'HH12:MI AM DD-MM-YYYY') AS end_time,
    tests.type,
    tests.threshold,
    jobs.job_id,
    jobs.title
FROM tests
JOIN jobs ON tests.job_id = jobs.job_id
WHERE tests.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
AND tests.end_time > NOW()
ORDER BY tests.end_time
`

type ScheduledTestsCompanyRow struct {
	TestID      int64
	TestName    string
	Description pgtype.Text
	Duration    int64
	QCount      int64
	EndTime     string
	Type        string
	Threshold   int32
	JobID       int64
	Title       string
}

func (q *Queries) ScheduledTestsCompany(ctx context.Context, userID int64) ([]ScheduledTestsCompanyRow, error) {
	rows, err := q.db.Query(ctx, scheduledTestsCompany, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledTestsCompanyRow
	for rows.Next() {
		var i ScheduledTestsCompanyRow
		if err := rows.Scan(
			&i.TestID,
			&i.TestName,
			&i.Description,
			&i.Duration,
			&i.QCount,
			&i.EndTime,
			&i.Type,
			&i.Threshold,
			&i.JobID,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signupUser = `-- name: SignupUser :one
INSERT INTO users (email, password, role) VALUES ($1, $2, $3)
RETURNING user_id, email, password, role, user_uuid, created_at, confirmed, is_verified
`

type SignupUserParams struct {
	Email    string
	Password string
	Role     int64
}

func (q *Queries) SignupUser(ctx context.Context, arg SignupUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signupUser, arg.Email, arg.Password, arg.Role)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.UserUuid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.IsVerified,
	)
	return i, err
}

const studentInfo = `-- name: StudentInfo :one
SELECT
    students.student_id,
    students.student_name,
    students.roll_number,
    students.student_dob,
    students.gender,
    students.course,
    students.department,
    students.year_of_study,
    students.cgpa,
    students.contact_no,
    students.address,
    students.skills, 
    students.picture_url AS profilePic,
    students.extras
FROM students
WHERE students.user_id = $1
`

type StudentInfoRow struct {
	StudentID   int64
	StudentName string
	RollNumber  string
	StudentDob  pgtype.Date
	Gender      string
	Course      string
	Department  string
	YearOfStudy string
	Cgpa        pgtype.Float8
	ContactNo   string
	Address     pgtype.Text
	Skills      pgtype.Text
	Profilepic  pgtype.Text
	Extras      []byte
}

func (q *Queries) StudentInfo(ctx context.Context, userID int64) (StudentInfoRow, error) {
	row := q.db.QueryRow(ctx, studentInfo, userID)
	var i StudentInfoRow
	err := row.Scan(
		&i.StudentID,
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.Cgpa,
		&i.ContactNo,
		&i.Address,
		&i.Skills,
		&i.Profilepic,
		&i.Extras,
	)
	return i, err
}

const studentProfileForCompany = `-- name: StudentProfileForCompany :one
SELECT
    students.student_name,
    students.roll_number,
    students.student_dob,
    students.gender,
    students.course,
    students.department,
    students.year_of_study,
    students.cgpa,
    students.contact_no,
    students.student_email,
    students.address,
    students.skills,
    students.extras
FROM applications
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
JOIN students ON applications.student_id = students.student_id
WHERE applications.student_id = $1 AND companies.user_id = $2
`

type StudentProfileForCompanyParams struct {
	StudentID int64
	UserID    int64
}

type StudentProfileForCompanyRow struct {
	StudentName  string
	RollNumber   string
	StudentDob   pgtype.Date
	Gender       string
	Course       string
	Department   string
	YearOfStudy  string
	Cgpa         pgtype.Float8
	ContactNo    string
	StudentEmail string
	Address      pgtype.Text
	Skills       pgtype.Text
	Extras       []byte
}

func (q *Queries) StudentProfileForCompany(ctx context.Context, arg StudentProfileForCompanyParams) (StudentProfileForCompanyRow, error) {
	row := q.db.QueryRow(ctx, studentProfileForCompany, arg.StudentID, arg.UserID)
	var i StudentProfileForCompanyRow
	err := row.Scan(
		&i.StudentName,
		&i.RollNumber,
		&i.StudentDob,
		&i.Gender,
		&i.Course,
		&i.Department,
		&i.YearOfStudy,
		&i.Cgpa,
		&i.ContactNo,
		&i.StudentEmail,
		&i.Address,
		&i.Skills,
		&i.Extras,
	)
	return i, err
}

const studentTestResult = `-- name: StudentTestResult :many
WITH tr AS (
    SELECT 
        result_id,
        SUM(time_taken) AS total_time_taken,
        COUNT(result_id) AS questions_attempted,
        COUNT(CASE WHEN points > 0 THEN 1 ELSE NULL END) AS correct_response
    FROM testresponses
    GROUP BY result_id
)
SELECT 
    testresults.result_id,
    TO_CHAR(testresults.start_time, 'HH12:MI:SS AM DD-MM-YYYY') AS start_time,
    TO_CHAR(testresults.end_time, 'HH12:MI:SS AM DD-MM-YYYY') AS end_time,
    testresults.score,

    students.student_id,
    students.student_name,
    students.roll_number,
    students.student_email,

    tr.total_time_taken,
    tr.questions_attempted,
    tr.correct_response,

    users.user_uuid
FROM testresults
JOIN students ON testresults.user_id = students.user_id
JOIN users ON testresults.user_id = users.user_id
JOIN tr ON testresults.result_id = tr.result_id
WHERE testresults.test_id = $1
`

type StudentTestResultRow struct {
	ResultID           int64
	StartTime          string
	EndTime            string
	Score              pgtype.Int8
	StudentID          int64
	StudentName        string
	RollNumber         string
	StudentEmail       string
	TotalTimeTaken     int64
	QuestionsAttempted int64
	CorrectResponse    int64
	UserUuid           pgtype.UUID
}

func (q *Queries) StudentTestResult(ctx context.Context, testID int64) ([]StudentTestResultRow, error) {
	rows, err := q.db.Query(ctx, studentTestResult, testID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentTestResultRow
	for rows.Next() {
		var i StudentTestResultRow
		if err := rows.Scan(
			&i.ResultID,
			&i.StartTime,
			&i.EndTime,
			&i.Score,
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
			&i.StudentEmail,
			&i.TotalTimeTaken,
			&i.QuestionsAttempted,
			&i.CorrectResponse,
			&i.UserUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const studentsOverview = `-- name: StudentsOverview :many
SELECT 
    students.student_id,
    students.student_name,
    students.roll_number,
    students.student_dob,
    students.gender,
    students.course,
    students.department,
    students.year_of_study,
    students.cgpa,
    students.contact_no,
    students.address,
    students.skills, 
    students.extras
FROM students
`

type StudentsOverviewRow struct {
	StudentID   int64
	StudentName string
	RollNumber  string
	StudentDob  pgtype.Date
	Gender      string
	Course      string
	Department  string
	YearOfStudy string
	Cgpa        pgtype.Float8
	ContactNo   string
	Address     pgtype.Text
	Skills      pgtype.Text
	Extras      []byte
}

func (q *Queries) StudentsOverview(ctx context.Context) ([]StudentsOverviewRow, error) {
	rows, err := q.db.Query(ctx, studentsOverview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentsOverviewRow
	for rows.Next() {
		var i StudentsOverviewRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.RollNumber,
			&i.StudentDob,
			&i.Gender,
			&i.Course,
			&i.Department,
			&i.YearOfStudy,
			&i.Cgpa,
			&i.ContactNo,
			&i.Address,
			&i.Skills,
			&i.Extras,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const submitTest = `-- name: SubmitTest :one
UPDATE testresults 
SET end_time = $1
WHERE user_id = $2 
AND test_id = $3
RETURNING result_id
`

type SubmitTestParams struct {
	EndTime pgtype.Timestamptz
	UserID  int64
	TestID  int64
}

func (q *Queries) SubmitTest(ctx context.Context, arg SubmitTestParams) (int64, error) {
	row := q.db.QueryRow(ctx, submitTest, arg.EndTime, arg.UserID, arg.TestID)
	var result_id int64
	err := row.Scan(&result_id)
	return result_id, err
}

const takeTest = `-- name: TakeTest :one
SELECT 
    tests.file_id,
    tests.duration,
    tests.end_time
FROM tests
JOIN applications ON applications.job_id = tests.job_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE user_id = $1)
AND tests.test_id = $2
`

type TakeTestParams struct {
	UserID int64
	TestID int64
}

type TakeTestRow struct {
	FileID   string
	Duration int64
	EndTime  pgtype.Timestamptz
}

func (q *Queries) TakeTest(ctx context.Context, arg TakeTestParams) (TakeTestRow, error) {
	row := q.db.QueryRow(ctx, takeTest, arg.UserID, arg.TestID)
	var i TakeTestRow
	err := row.Scan(&i.FileID, &i.Duration, &i.EndTime)
	return i, err
}

const testAuthorization = `-- name: TestAuthorization :one
SELECT 
    tests.test_id
FROM tests
WHERE tests.test_id = $1
AND tests.company_id = (SELECT company_id FROM companies WHERE companies.user_id = $2)
AND tests.end_time < NOW()
`

type TestAuthorizationParams struct {
	TestID int64
	UserID int64
}

func (q *Queries) TestAuthorization(ctx context.Context, arg TestAuthorizationParams) (int64, error) {
	row := q.db.QueryRow(ctx, testAuthorization, arg.TestID, arg.UserID)
	var test_id int64
	err := row.Scan(&test_id)
	return test_id, err
}

const testData = `-- name: TestData :one
SELECT 
    tests.file_id,
    tests.test_id,
    tests.test_name,
    tests.q_count,
    TO_CHAR(tests.end_time, 'HH12:MI AM DD-MM-YYYY') AS end_time,
    tests.threshold,
    jobs.title,
    companies.company_name,
    companies.representative_email
FROM tests
JOIN companies ON tests.company_id = companies.company_id
JOIN jobs ON tests.job_id = jobs.job_id
WHERE tests.test_id = $1
`

type TestDataRow struct {
	FileID              string
	TestID              int64
	TestName            string
	QCount              int64
	EndTime             string
	Threshold           int32
	Title               string
	CompanyName         string
	RepresentativeEmail string
}

func (q *Queries) TestData(ctx context.Context, testID int64) (TestDataRow, error) {
	row := q.db.QueryRow(ctx, testData, testID)
	var i TestDataRow
	err := row.Scan(
		&i.FileID,
		&i.TestID,
		&i.TestName,
		&i.QCount,
		&i.EndTime,
		&i.Threshold,
		&i.Title,
		&i.CompanyName,
		&i.RepresentativeEmail,
	)
	return i, err
}

const testHistory = `-- name: TestHistory :many
SELECT 
    tests.test_id,
    tests.test_name,
    TO_CHAR(testresults.start_time, 'HH12:MI AM DD-MM-YYYY') AS start_time
FROM testresults
JOIN tests ON testresults.test_id = tests.test_id
WHERE testresults.user_id = $1
ORDER BY testresults.start_time DESC
`

type TestHistoryRow struct {
	TestID    int64
	TestName  string
	StartTime string
}

func (q *Queries) TestHistory(ctx context.Context, userID int64) ([]TestHistoryRow, error) {
	rows, err := q.db.Query(ctx, testHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestHistoryRow
	for rows.Next() {
		var i TestHistoryRow
		if err := rows.Scan(&i.TestID, &i.TestName, &i.StartTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testMetadata = `-- name: TestMetadata :one
SELECT 
    tests.test_id,
    tests.test_name,
    tests.description,
    tests.duration,
    tests.q_count,
    TO_CHAR(tests.end_time, 'HH12:MI AM DD-MM-YYYY') AS end_time,
    tests.type,    
    companies.company_name,
    jobs.title
FROM applications
JOIN tests ON applications.job_id = tests.job_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
AND tests.test_id = $2
`

type TestMetadataParams struct {
	UserID int64
	TestID int64
}

type TestMetadataRow struct {
	TestID      int64
	TestName    string
	Description pgtype.Text
	Duration    int64
	QCount      int64
	EndTime     string
	Type        string
	CompanyName string
	Title       string
}

func (q *Queries) TestMetadata(ctx context.Context, arg TestMetadataParams) (TestMetadataRow, error) {
	row := q.db.QueryRow(ctx, testMetadata, arg.UserID, arg.TestID)
	var i TestMetadataRow
	err := row.Scan(
		&i.TestID,
		&i.TestName,
		&i.Description,
		&i.Duration,
		&i.QCount,
		&i.EndTime,
		&i.Type,
		&i.CompanyName,
		&i.Title,
	)
	return i, err
}

const testPassFailCount = `-- name: TestPassFailCount :one
SELECT
    COUNT(CASE WHEN testresults.score >= $2 THEN 1 ELSE NULL END) AS pass_count,
    COUNT(CASE WHEN testresults.score < $2 THEN 1 ELSE NULL END) AS fail_count
FROM testresults
WHERE testresults.test_id = $1
`

type TestPassFailCountParams struct {
	TestID int64
	Score  pgtype.Int8
}

type TestPassFailCountRow struct {
	PassCount int64
	FailCount int64
}

func (q *Queries) TestPassFailCount(ctx context.Context, arg TestPassFailCountParams) (TestPassFailCountRow, error) {
	row := q.db.QueryRow(ctx, testPassFailCount, arg.TestID, arg.Score)
	var i TestPassFailCountRow
	err := row.Scan(&i.PassCount, &i.FailCount)
	return i, err
}

const testResultPoller = `-- name: TestResultPoller :one
SELECT  
    tests.test_id
FROM tests
WHERE tests.end_time < NOW()
AND tests.result_url IS NULL
LIMIT 1
`

func (q *Queries) TestResultPoller(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, testResultPoller)
	var test_id int64
	err := row.Scan(&test_id)
	return test_id, err
}

const upcomingInterviewsStudent = `-- name: UpcomingInterviewsStudent :many
SELECT 
    companies.company_name,
    jobs.title,
    interviews.interview_id,
    TO_CHAR(interviews.date_time, 'HH12:MI AM DD-MM-YYYY') AS date_time,
    interviews.type::TEXT,
    interviews.location,
    interviews.notes
FROM applications
JOIN interviews ON applications.application_id = interviews.application_id 
                AND interviews.status != 'Completed'
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
AND interviews.date_time > NOW()
`

type UpcomingInterviewsStudentRow struct {
	CompanyName    string
	Title          string
	InterviewID    int64
	DateTime       string
	InterviewsType string
	Location       string
	Notes          pgtype.Text
}

func (q *Queries) UpcomingInterviewsStudent(ctx context.Context, userID int64) ([]UpcomingInterviewsStudentRow, error) {
	rows, err := q.db.Query(ctx, upcomingInterviewsStudent, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpcomingInterviewsStudentRow
	for rows.Next() {
		var i UpcomingInterviewsStudentRow
		if err := rows.Scan(
			&i.CompanyName,
			&i.Title,
			&i.InterviewID,
			&i.DateTime,
			&i.InterviewsType,
			&i.Location,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upcomingTestsStudent = `-- name: UpcomingTestsStudent :many
SELECT 
    tests.test_id,
    tests.test_name,
    tests.description,
    tests.duration,
    tests.q_count,
    TO_CHAR(tests.end_time, 'HH12:MI AM DD-MM-YYYY') AS end_time,
    tests.type,    
    companies.company_name,
    jobs.title
FROM applications 
JOIN tests ON applications.job_id = tests.job_id
JOIN jobs ON applications.job_id = jobs.job_id
JOIN companies ON jobs.company_id = companies.company_id
WHERE applications.student_id = (SELECT student_id FROM students WHERE students.user_id = $1)
AND NOT EXISTS (SELECT 1 FROM testresults WHERE testresults.test_id = tests.test_id AND testresults.user_id = $1)
AND tests.end_time > NOW()
`

type UpcomingTestsStudentRow struct {
	TestID      int64
	TestName    string
	Description pgtype.Text
	Duration    int64
	QCount      int64
	EndTime     string
	Type        string
	CompanyName string
	Title       string
}

func (q *Queries) UpcomingTestsStudent(ctx context.Context, userID int64) ([]UpcomingTestsStudentRow, error) {
	rows, err := q.db.Query(ctx, upcomingTestsStudent, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpcomingTestsStudentRow
	for rows.Next() {
		var i UpcomingTestsStudentRow
		if err := rows.Scan(
			&i.TestID,
			&i.TestName,
			&i.Description,
			&i.Duration,
			&i.QCount,
			&i.EndTime,
			&i.Type,
			&i.CompanyName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmailConfirmation = `-- name: UpdateEmailConfirmation :exec
UPDATE users
SET confirmed = true
WHERE email = $1
`

func (q *Queries) UpdateEmailConfirmation(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, updateEmailConfirmation, email)
	return err
}

const updateInterview = `-- name: UpdateInterview :one
UPDATE interviews
SET 
    date_time = $3,
    type = $4,
    notes = $5,
    location = $6
WHERE company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $1)
AND interview_id = $2
RETURNING application_id, TO_CHAR(date_time, 'HH12:MI AM DD-MM-YYYY') AS date_time
`

type UpdateInterviewParams struct {
	UserID      int64
	InterviewID int64
	DateTime    pgtype.Timestamptz
	Type        interface{}
	Notes       pgtype.Text
	Location    string
}

type UpdateInterviewRow struct {
	ApplicationID int64
	DateTime      string
}

func (q *Queries) UpdateInterview(ctx context.Context, arg UpdateInterviewParams) (UpdateInterviewRow, error) {
	row := q.db.QueryRow(ctx, updateInterview,
		arg.UserID,
		arg.InterviewID,
		arg.DateTime,
		arg.Type,
		arg.Notes,
		arg.Location,
	)
	var i UpdateInterviewRow
	err := row.Scan(&i.ApplicationID, &i.DateTime)
	return i, err
}

const updateJob = `-- name: UpdateJob :exec
UPDATE jobs
SET location = $1,
    title = $2,
    description = $3,
    type = $4,
    salary = $5,
    skills = $6,
    position = $7,
    extras = $8
WHERE job_id = $9
AND company_id = (SELECT company_id FROM companies WHERE companies.user_id = $10)
`

type UpdateJobParams struct {
	Location    string
	Title       string
	Description pgtype.Text
	Type        string
	Salary      string
	Skills      []string
	Position    string
	Extras      []byte
	JobID       int64
	UserID      int64
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) error {
	_, err := q.db.Exec(ctx, updateJob,
		arg.Location,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.Salary,
		arg.Skills,
		arg.Position,
		arg.Extras,
		arg.JobID,
		arg.UserID,
	)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password = $2
WHERE email = $1
`

type UpdatePasswordParams struct {
	Email    string
	Password string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.Email, arg.Password)
	return err
}

const updateResponse = `-- name: UpdateResponse :exec
INSERT INTO testresponses (result_id, question_id, response, time_taken)
VALUES ($1, $2, $3, $4)
ON CONFLICT (result_id, question_id)
DO UPDATE SET response = $3, time_taken = $4
`

type UpdateResponseParams struct {
	ResultID   int64
	QuestionID string
	Response   []string
	TimeTaken  pgtype.Int8
}

func (q *Queries) UpdateResponse(ctx context.Context, arg UpdateResponseParams) error {
	_, err := q.db.Exec(ctx, updateResponse,
		arg.ResultID,
		arg.QuestionID,
		arg.Response,
		arg.TimeTaken,
	)
	return err
}

const updateStudentDetails = `-- name: UpdateStudentDetails :exec
UPDATE students
SET course = $1,
    department = $2,
    year_of_study = $3,
    cgpa = $4,
    contact_no = $5,
    address = $6,
    skills = $7
WHERE user_id = $8
`

type UpdateStudentDetailsParams struct {
	Course      string
	Department  string
	YearOfStudy string
	Cgpa        pgtype.Float8
	ContactNo   string
	Address     pgtype.Text
	Skills      pgtype.Text
	UserID      int64
}

func (q *Queries) UpdateStudentDetails(ctx context.Context, arg UpdateStudentDetailsParams) error {
	_, err := q.db.Exec(ctx, updateStudentDetails,
		arg.Course,
		arg.Department,
		arg.YearOfStudy,
		arg.Cgpa,
		arg.ContactNo,
		arg.Address,
		arg.Skills,
		arg.UserID,
	)
	return err
}

const updateStudentProfilePic = `-- name: UpdateStudentProfilePic :exec
UPDATE students
SET
    picture_url = $1
WHERE user_id = $2
`

type UpdateStudentProfilePicParams struct {
	PictureUrl pgtype.Text
	UserID     int64
}

func (q *Queries) UpdateStudentProfilePic(ctx context.Context, arg UpdateStudentProfilePicParams) error {
	_, err := q.db.Exec(ctx, updateStudentProfilePic, arg.PictureUrl, arg.UserID)
	return err
}

const updateStudentResult = `-- name: UpdateStudentResult :exec
UPDATE students
SET
    result_url = $1
WHERE user_id = $2
`

type UpdateStudentResultParams struct {
	ResultUrl string
	UserID    int64
}

func (q *Queries) UpdateStudentResult(ctx context.Context, arg UpdateStudentResultParams) error {
	_, err := q.db.Exec(ctx, updateStudentResult, arg.ResultUrl, arg.UserID)
	return err
}

const updateStudentResume = `-- name: UpdateStudentResume :exec
UPDATE students
SET
    resume_url = $1
WHERE user_id = $2
`

type UpdateStudentResumeParams struct {
	ResumeUrl pgtype.Text
	UserID    int64
}

func (q *Queries) UpdateStudentResume(ctx context.Context, arg UpdateStudentResumeParams) error {
	_, err := q.db.Exec(ctx, updateStudentResume, arg.ResumeUrl, arg.UserID)
	return err
}

const updateTest = `-- name: UpdateTest :exec
UPDATE tests 
SET 
    threshold = COALESCE($3, threshold),
    published = COALESCE($4, published)
WHERE tests.test_id = $1
AND tests.company_id = (SELECT companies.company_id FROM companies WHERE companies.user_id = $2)
`

type UpdateTestParams struct {
	TestID    int64
	UserID    int64
	Threshold pgtype.Int4
	Published pgtype.Bool
}

func (q *Queries) UpdateTest(ctx context.Context, arg UpdateTestParams) error {
	_, err := q.db.Exec(ctx, updateTest,
		arg.TestID,
		arg.UserID,
		arg.Threshold,
		arg.Published,
	)
	return err
}

const updateTestResultURLUnprotected = `-- name: UpdateTestResultURLUnprotected :exec
UPDATE tests
SET 
    result_url = $2
WHERE test_id = $1
`

type UpdateTestResultURLUnprotectedParams struct {
	TestID    int64
	ResultUrl pgtype.Text
}

func (q *Queries) UpdateTestResultURLUnprotected(ctx context.Context, arg UpdateTestResultURLUnprotectedParams) error {
	_, err := q.db.Exec(ctx, updateTestResultURLUnprotected, arg.TestID, arg.ResultUrl)
	return err
}

const usersTableData = `-- name: UsersTableData :one
SELECT 
    TO_CHAR(users.created_at, 'HH12:MI AM DD-MM-YYYY') AS created_at,
    users.confirmed,
    users.is_verified
FROM users
WHERE users.user_id = $1
`

type UsersTableDataRow struct {
	CreatedAt  string
	Confirmed  bool
	IsVerified bool
}

func (q *Queries) UsersTableData(ctx context.Context, userID int64) (UsersTableDataRow, error) {
	row := q.db.QueryRow(ctx, usersTableData, userID)
	var i UsersTableDataRow
	err := row.Scan(&i.CreatedAt, &i.Confirmed, &i.IsVerified)
	return i, err
}

const verifyStudent = `-- name: VerifyStudent :exec
UPDATE users
SET is_verified = true
WHERE user_id = $1
`

func (q *Queries) VerifyStudent(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, verifyStudent, userID)
	return err
}
